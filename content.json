{"posts":[{"title":"任意位置删除一个节点","text":"设计一个Delete（position）函数，删除第position位的节点。 思路1）重新连接删除后的链表将第n-1位节点的next存第n+1位节点的地址，即第n位节点的next。 2）清除第n位节点在堆区的内存占用使用 free( )。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;struct Node{ int data; struct Node* next;};struct Node* head; //globalvoid Insert(int n){ struct Node* temp = (struct Node*)malloc(sizeof(struct Node)); temp-&gt;data = n; temp-&gt;next = NULL; struct Node* temp1 = head; if(head == NULL){ head = temp; return; } while(temp1-&gt;next != NULL){ temp1 = temp1-&gt;next; } temp1-&gt;next = temp;}void Print(){ struct Node* temp = head; while(temp != NULL){ printf(&quot;%d &quot;,temp-&gt;data); temp = temp-&gt;next; } printf(&quot;\\n&quot;);}void Delete(int n){ struct Node* temp1 = head; if(n==1){ head = temp1-&gt;next; free(temp1); return; } for(int i=0;i&lt;n-2;i++) temp1 = temp1-&gt;next; struct Node* temp2 = temp1-&gt;next; temp1-&gt;next = temp2-&gt;next; //temp1-&gt;next--第n-1位节点的next //temp2-&gt;next-第n+1位节点的next free(temp2);}int main(){ head = NULL; Insert(2); Insert(4); Insert(6); Insert(5); Print(); int n; for(int i=0;i&lt;3;i++){ printf(&quot;Enter the position\\n&quot;); scanf(&quot;%d&quot;,&amp;n); Delete (n); Print(); } return 0;} 输入/出结果123456789102 4 6 5Enter the position14 6 5Enter the position34 6Enter the position24","link":"/2023/01/03/202213-%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/"},{"title":"使用栈实现中缀到后缀表达式的转换","text":"前缀、中缀与后缀表达式计算机中一般使用三种表达式，分别是中缀表达式(Infix)、前缀表达式(Prefix)、后缀表达式(Postfix)。 下表列出了它们的基本表示形式： 类型 Infix Prefix Postfix 形式 &lt;operand&gt;&lt;operator&gt;&lt;operand&gt; &lt;operator&gt;&lt;operand&gt;&lt;operand&gt; &lt;operand&gt;&lt;operand&gt;&lt;operator&gt; 例子 a+b*c +a*bc abc*+ 后缀表达式的计算方法为什么要将表意清晰的中缀表达式转换成形式比较特殊的后缀表达式呢？这是因为中缀表达式的运算需要人为地遵循一些运算法则，而后缀表达式只需要遵循一个固定的运算法则即可完成运算。 后缀表达式的计算方法为： 从左到右对后缀表达式进行扫描，当遇到运算符时，将运算符与它前面两个数字组合成一个算式进行计算，用结果取代两个数字以及运算符的位置，继续向后扫描，直到表达式变成一个值，该值即为表达式的值。 我们发现，这与栈的工作模式非常类似，于是，可以写出以下代码： 12345678910111213141516int EvaluatePostfix(int exp[]){ stack&lt;int&gt; S; for(int i = 0 ; i &lt;= strlen(exp)-1 ; i++){ if(exp[i] is operand)//如果是操作数，就入栈 S.push(exp[i]); else if(exp[i] is operator){//如果是操作符，将栈最上面两个操作数pop并保存在op1和op2中 int op1 = S.top(); S.pop(); int op2 = S.top(); S.pop(); res = Perform(exp[i],op1,op2);//Perform函数读取操作符和两个操作数并运算，返回得数 S.push(res);//将得数入栈 } } return S.top();//最后留在栈中的数字即为表达式的得数} 将中缀表达式转换为后缀表达式那么如何将Infix转换为Postfix，从而可以被程序计算呢？ 对比两种表达式 Infix: A + B * C Postfix:A B C * + 我们发现操作数之间的相对位置并无改变，只是操作符的位置发生变化。下面提供一个转换的方法，依然使用栈来实现。 Infix A + B * C - D * E Postfix A Stack Infix A + B * C - D * E Postfix AB Stack + 现在我们遇到了第二个符号，如果此时栈顶符号的运算级别大于等于该符号，那么就将栈顶的符号弹出并且加入Postfix，直到不符合该条件或者栈为空时，将该符号（也就是遍历到的符号）入栈。 Infix A + B * C - D * E Postfix AB Stack + * 直到遍历结束，将栈中剩余符号依次全部弹出并加入Postfix。 Infix A + B * C - D * E Postfix A B C * + D E * - Stack 但是我们并没有考虑Infix带括号的情况。如果表达式带括号的话，解决方案如下： 遇到左括号让左括号入栈，如果栈顶是左括号，遇到操作符直接入栈 直到遇到右括号，将栈顶的元素弹出并加入Postfix直到遇到对应的左括号时停止 综合以上方法可以写出对应代码 123456789101112131415161718192021222324252627282930void InfixtoPostfix(char exp[],char res[]){ stack&lt;char&gt; S; int j=0; for(int i=0;i&lt;=strlen(exp)-1;i++){ if(exp[i] is operand) res[j++] = exp[i]; else if(exp[i] is operator){ while(!S.empty()&amp;&amp;HasHigherPrec(S.top,exp[i])&amp;&amp;!IsOpeningParentheses(S.top())){//HasHigherPrec函数即栈顶符号优先级大于等于第i个符号时返回true，否则返回false //IsOpeningParentheses函数功能是检查栈顶是否是左括号，是返回true，否返回false res[j++] = S.top(); S.pop(); } S.push(exp[i]); } else if(exp[i] == '(') S.push(exp[i]); else if(exp[i] == ')'){ while(!S.empty()&amp;&amp;!IsOpeningParentheses(S.top())){ res[j++] = S.top(); S.pop(); } S.pop();//这次pop是为了pop出栈中的左括号 } } while(!S.empty()){ res[j++] = S.top(); S.pop(); }} 编写10以内的混合运算计算器任务输入包括10以内的数字和+、-、*、(、)运算符的合法表达式，输出它的Infix、Postfix以及运算结果。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;bool Isoperator(char c){ if(c == '+'||c == '-'||c == '*') return true; else return false;}bool HasHigherPrec(char a,char b){ if(b == '+'||b == '-') return true; else{ if(a == '*') return true; else return false; }}bool IsopeningPar(char c){ if(c == '(') return true; else return false;}void InfixtoPostfix(char exp[],char res[]){ int j=0; stack&lt;char&gt; S; for(int i = 0; i &lt;= strlen(exp)-1 ;i++){ if(exp[i]&gt;=48&amp;&amp;exp[i]&lt;=57){ res[j++] = exp[i]; } else if(Isoperator(exp[i])){ while(!S.empty()&amp;&amp;HasHigherPrec(S.top(),exp[i])&amp;&amp;!IsopeningPar(S.top())){ res[j++] = S.top(); S.pop(); } S.push(exp[i]); } else if(exp[i]=='(') S.push(exp[i]); else if(exp[i]==')'){ while(!S.empty()&amp;&amp;!IsopeningPar(S.top())){ res[j++] = S.top(); S.pop(); } S.pop(); } } while(!S.empty()){ res[j++] = S.top(); S.pop(); }}int Perform(char c,int a,int b){ if(c == '+') return b+a; if(c == '-') return b-a; if(c == '*') return b*a;} int EvaluatePostfix(char res[]){ stack&lt;int&gt; A; int op1,op2,op; for(int i=0;i&lt;=strlen(res)-1;i++){ if(!Isoperator(res[i])) A.push((int)(res[i]-'0')); else if(Isoperator(res[i])){ op1 = A.top(); A.pop(); op2 = A.top(); A.pop(); op = Perform(res[i],op1,op2); A.push(op); } }return A.top();}int main(){ char exp[100]; char res[100]; gets(exp); printf(&quot;Infix: %s\\n&quot;,exp); InfixtoPostfix(exp,res); printf(&quot;Postfix: %s\\n&quot;,res); printf(&quot;The result is %d&quot;,EvaluatePostfix(res)); return 0;} 输入/出结果1234((1+2)*3-4)*5+(6-7)Infix: ((1+2)*3-4)*5+(6-7)Postfix: 12+3*4-5*67-+The result is 24","link":"/2023/01/10/2023110-%E4%BD%BF%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E4%B8%AD%E7%BC%80%E5%88%B0%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%BD%AC%E6%8D%A2/"},{"title":"反转链表（迭代及递归实现）","text":"从上图中可以看出，反转一个链表只需要改变Node.link。 I. 迭代实现思路设置三个结构体指针Prev、current、next，分别保存之前的节点的地址、目前的节点地址、之后的节点地址。 代码实现123456789101112void Reverse(){ struct Node *current, *prev, *next; current = head; prev = NULL; while(current != NULL){ next = current-&gt;next;//next 用来存储当前Node的next，当Node.next被prev覆盖后，next将值赋 给current从而进入下一个循环。 current-&gt;next = prev; prev = current; current = next; } head = prev;} 完整代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;struct Node{ int data; struct Node* next;};struct Node* head;void Insert(int n){ struct Node* temp = (struct Node*)malloc(sizeof(struct Node)); temp-&gt;data = n; temp-&gt;next = NULL; struct Node* temp1 = head; if(head == NULL){ head = temp; return; } while(temp1-&gt;next != NULL){ temp1 = temp1-&gt;next; } temp1-&gt;next = temp;}void Print(){ struct Node* temp = head; while(temp != NULL){ printf(&quot;%d &quot;,temp-&gt;data); temp = temp-&gt;next; } printf(&quot;\\n&quot;);}void Reverse(){ struct Node *current, *prev, *next; current = head; prev = NULL; while(current != NULL){ next = current-&gt;next;//next 用来存储当前Node的next，当Node.next被prev覆盖后，next将值赋 给current从而进入下一个循环。 current-&gt;next = prev; prev = current; current = next; } head = prev;}int main(){ head = NULL; Insert(2); Insert(4); Insert(6); Insert(5); Print(); Reverse(); Print(); return 0;} 输出结果： 122 4 6 55 6 4 2 II. 递归实现1）递归实现输出的反转我们先写一个递归形式的Print函数，因为递归需要给函数传参，因此函数形式为Print(struct Node* p)。 12345678void Print(struct Node* p){//p初始为头节点的地址 if(p == NULL){ printf(&quot;\\n&quot;); return; } printf(&quot;%d &quot;,p-&gt;data); Print(p-&gt;next);} 此时总是先输出再调用函数自身，因此是正向输出。如果我们将printf与Print两行代码交换位置，即 12345void Print(struct Node* p){//p初始为头节点的地址 if(p == NULL) return; Print(p-&gt;next); printf(&quot;%d &quot;,p-&gt;data);} 那么函数会在输出之前先进行重复调用，进行到递归结束条件后，依次执行输出。 完整代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;struct Node{ int data; struct Node* next;};struct Node* head;void Insert(int n){ struct Node* temp = (struct Node*)malloc(sizeof(struct Node)); temp-&gt;data = n; temp-&gt;next = NULL; struct Node* temp1 = head; if(head == NULL){ head = temp; return; } while(temp1-&gt;next != NULL){ temp1 = temp1-&gt;next; } temp1-&gt;next = temp;}void Print(){ struct Node* temp = head; while(temp != NULL){ printf(&quot;%d &quot;,temp-&gt;data); temp = temp-&gt;next; } printf(&quot;\\n&quot;);}void ReversePrint(struct Node* p){//p初始为头节点的地址 if(p == NULL) return; ReversePrint(p-&gt;next); printf(&quot;%d &quot;,p-&gt;data);}int main(){ head = NULL; Insert(2); Insert(4); Insert(6); Insert(5); Print(); ReversePrint(head); return 0;} 输出结果122 4 6 55 6 4 2 2）递归实现链表反转反转输出并没有实现链表的反转，因为head、next的值都没有发生改变。但是我们依然可以采用递归的方式实现链表的反转。 设计一个Reverse函数，使得其能够以递归方式实现链表反转。12345678910void Reverse(struct Node* p){//p初始为头节点的地址 if(p-&gt;next == NULL){ head = p; return; } Reverse(p-&gt;next); struct Node* q = p-&gt;next; q-&gt;next = p;//也可以简洁地表示为p-&gt;next-&gt;next = p p-&gt;next = NULL;} 完整代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;struct Node{ int data; struct Node* next;};struct Node* head;void Insert(int n){ struct Node* temp = (struct Node*)malloc(sizeof(struct Node)); temp-&gt;data = n; temp-&gt;next = NULL; struct Node* temp1 = head; if(head == NULL){ head = temp; return; } while(temp1-&gt;next != NULL){ temp1 = temp1-&gt;next; } temp1-&gt;next = temp;}void Print(){ struct Node* temp = head; while(temp != NULL){ printf(&quot;%d &quot;,temp-&gt;data); temp = temp-&gt;next; } printf(&quot;\\n&quot;);}void Reverse(struct Node* p){//p初始为头节点的地址 if(p-&gt;next == NULL){ head = p; return; } Reverse(p-&gt;next); struct Node* q = p-&gt;next; q-&gt;next = p; p-&gt;next = NULL;}int main(){ head = NULL; Insert(2); Insert(4); Insert(6); Insert(5); Print(); Reverse(head); Print(); return 0;}","link":"/2023/01/03/202213-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%EF%BC%88%E8%BF%AD%E4%BB%A3%E5%8F%8A%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%EF%BC%89/"},{"title":"队列(Queue)的数组和链表实现","text":"Introduction of Queue队列作为一种抽象数据结构，遵循First-In-First-Out(FIFO)原则。 它的定义如下： A list or collection with the restriction that insertion can be performed at one end (rear) and deletion can be performed at other end (front). 队列的操作有以下几种： Enqueue(x) 入队列 Dequeue( ) 出队列（并返回删除队列的值） front( ) and rear( ) IsEmpty( ) 以上操作的时间复杂度均为O(1). 队列的实现用数组实现我们分别定义两个变量front和rear来储存队首和队尾，队列为空时令front = -1 rear = -1。 但是我们发现随着不断地Enqueue和Dequeue，队列逐渐后移，前面数组空间无法重复利用。于是我们采用循环数组，循环数组可以想象成是数组首尾相连，因此我们这样表示它的位置： current position: i next position: (i+1)%N previous position: (i+N-1)%N (N表示开辟数组的长度) 代码实现 IsEmpty( ) 123456bool IsEmpty(){ if(front == -1 &amp;&amp; rear == -1) return true; else return false;} Enqueue( x ) 12345678910111213void Enqueue(int x){ if((rear+1)%N == front)//rear向后一格与front重合，说明循环数组已满 return; else if(IsEmpty()){ front = 0; rear = 0; A[rear] = x; } else{ rear = (rear + 1) % N; A[rear] = x; }} Dequeue( ) 1234567891011void Dequeue(){ if(IsEmpty()) return; else if(front == rear){ front = -1; rear = -1; } else{ front = (front + 1) % N; }} front( )和rear( ) 123456int front(){ return A[front];}int rear(){ return A[rear];} 用链表实现Enqueue和Dequeue操作必然一个在链表头一个在链表尾，为了保证两个操作的时间复杂度都是O(1)，要设置两个指针front和rear。 代码实现12345678910111213141516171819202122232425262728struct Node{ int data; struct Node* next;}struct Node* front = NULL;struct Node* front = NULL;void Enqueue(int x){ struct Node* temp = (struct Node*)malloc(sizeof(struct Node)); temp-&gt;data = x; temp-&gt;next = NULL; if(front == NULL &amp;&amp; rear == NULL){ front = temp; rear = temp; return; } rear-&gt;next = temp; rear = temp;}void Dequeue(){ struct Node* temp = front; if(front = NULL) return; if(front == rear){ front = NULL; rear = NULL; } else{ front = front-&gt;next; } free(temp);}","link":"/2023/01/11/2023111-%E9%98%9F%E5%88%97(Queue)%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0/"},{"title":"二叉搜索树的C++递归实现","text":"树的介绍树(Tree)作为一种数据结构，具有一种递归性。一个树可以看作是由根节点(root)以及若干子树构成，而子树又可以继续向下分成根和子树，因此树具有递归性。 二叉树(binary tree)是树中的一种，它满足每个节点都有要么2个要么0个子节点的特性。 二叉搜索树(binary search tree)满足左侧子树中储存的值都小于等于root，而右侧子树上的值都大于root，并且递归满足。 搜索效率比较 Operation Array Linked-list Array(sorted) BST Search(n) O(n) O(n) O(logn) O(logn) Insert(x) O(1) O(1) O(n) O(logn) Remove(n) O(n) O(n) O(n) O(logn) 可以看出二叉搜索树在处理数据方面更有优势。 二叉搜索树的递归实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;using namespace std;struct BstNode { int data; struct BstNode* left; struct BstNode* right;};BstNode* GetNewNode(int data) { BstNode* NewNode = (BstNode*)malloc(sizeof(BstNode)); NewNode-&gt;data = data; NewNode-&gt;left = NULL; NewNode-&gt;right = NULL; return NewNode;}BstNode* Insert(BstNode* root, int data) { if (root == NULL) { root = GetNewNode(data); } else if (data &lt;= root-&gt;data) { root-&gt;left = Insert(root-&gt;left, data); } else { root-&gt;right = Insert(root-&gt;right, data); } return root;}bool Search(BstNode* root, int data) { if (root == NULL) return false; else if (root-&gt;data == data) return true; else if (data &lt;= root-&gt;data) return Search(root-&gt;left, data); else return Search(root-&gt;right, data);}int main() { BstNode* root; root = NULL; root = Insert(root, 15); root = Insert(root, 10); root = Insert(root, 10); root = Insert(root, 25); root = Insert(root, 8); root = Insert(root, 12); int number; cout &lt;&lt; &quot;Enter number be searched\\n&quot;; cin &gt;&gt; number; if (Search(root, number))cout &lt;&lt; &quot;Found\\n&quot;; else cout &lt;&lt; &quot;Not Found\\n&quot;;} 用二叉搜索树查找最大最小值我们发现，一直向左节点走会找到最小值，而一直向右节点走会找到最大值。 代码如下（最小值是迭代实现，最大值是递归实现）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;using namespace std;struct BstNode { int data; BstNode* left; BstNode* right;};int FindMin(BstNode* root) { if (root == NULL) { printf(&quot;Error:Tree is empty\\n&quot;); return -1; } while (root-&gt;left != NULL) { root = root-&gt;left; } return root-&gt;data;}int FindMaxRecursion(BstNode* root) { if (root == NULL) { printf(&quot;Error\\n&quot;); return -1; } else if (root-&gt;right == NULL) { return root-&gt;data; } return FindMaxRecursion(root-&gt;right);}BstNode* GetNewNode(int data) { BstNode* NewNode = new BstNode(); NewNode-&gt;data = data; NewNode-&gt;left = NewNode-&gt;right = NULL; return NewNode;}BstNode* Insert(BstNode* root, int data) { if (root == NULL) { root = GetNewNode(data); } else if (data &lt;= root-&gt;data) { root-&gt;left = Insert(root-&gt;left, data); } else { root-&gt;right = Insert(root-&gt;right, data); } return root;}int main() { BstNode* root = NULL; root = Insert(root, 10); root = Insert(root, 15); root = Insert(root, 5); root = Insert(root, 25); root = Insert(root, 20); printf(&quot;The max is %d\\n&quot;, FindMaxRecursion(root)); printf(&quot;The min is %d\\n&quot;, FindMin(root)); return 0;}","link":"/2023/01/13/2023113-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84C++%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0/"},{"title":"二叉树的遍历","text":"Tree Traversal Tree traversal is a process of visiting each node in the tree exactly once in some order. 树的遍历有2种方式，Breadth-first（广度优先）和Depth-first（深度优先）。 Breadth-first（广度优先）按照广度优先，对二叉树的遍历方式主要是Level-order（层序遍历）。 Level-order（层序遍历）层序遍历即对一个二叉树每层从上到下，从左到右进行遍历。 上图层序遍历顺序即为F D J B E G K A C I H. 实现用队列可以实现层序遍历。因为队列有First-In-First-Out(FIFO)原则，我们可以先让root进入队列，在访问节点时，让其左右节点进入队列。 实现层序遍历的代码如下： 代码12345678910111213#include&lt;queue&gt;//可以直接调用库函数使用队列，其基本语法与Stack类似void LevelOrder(BstNode* root) { if (root == NULL)return; queue&lt;BstNode*&gt; Q; Q.push(root); while (!Q.empty()) { BstNode* current = Q.front(); cout &lt;&lt; current-&gt;data &lt;&lt; &quot; &quot;; if (current-&gt;left != NULL)Q.push(current-&gt;left); if (current-&gt;right != NULL)Q.push(current-&gt;right); Q.pop(); }} Depth-first（深度优先）深度优先有三个排序方法，Preorder（前序）、Inorder（中序）和Postorder（后序）。 类型 Order Preorder &lt;root&gt;&lt;left&gt;&lt;right&gt;(DLR) Inorder &lt;left&gt;&lt;root&gt;&lt;right&gt;(LDR) Postorder &lt;left&gt;&lt;right&gt;&lt;root&gt;(LRD) 上图三种不同方式的排列顺序分别为： Preorder: F D B A C E J G I H K Inorder: A B C D E F G H I J K Postorder: A C B E D H I G K J F 实现三种顺序都可以用递归来简洁地写出，代码如下： 代码123456789101112131415161718void Preorder(BstNode* root) { if (root == NULL)return; printf(&quot;%d &quot;, root-&gt;data); Preorder(root-&gt;left); Preorder(root-&gt;right);}void Inorder(BstNode* root) { if (root == NULL)return; Inorder(root-&gt;left); printf(&quot;%d &quot;, root-&gt;data); Inorder(root-&gt;right);}void Postorder(BstNode* root) { if (root == NULL)return; Postorder(root-&gt;left); Postorder(root-&gt;right); printf(&quot;%d &quot;, root-&gt;data);} 最后附上完整代码，输出树的高度，层序遍历，前序，中序，后序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;struct BstNode { int data; BstNode* left; BstNode* right;};void LevelOrder(BstNode* root) { if (root == NULL)return; queue&lt;BstNode*&gt; Q; Q.push(root); while (!Q.empty()) { BstNode* current = Q.front(); cout &lt;&lt; current-&gt;data &lt;&lt; &quot; &quot;; if (current-&gt;left != NULL)Q.push(current-&gt;left); if (current-&gt;right != NULL)Q.push(current-&gt;right); Q.pop(); } printf(&quot;\\n&quot;);}void Preorder(BstNode* root) { if (root == NULL)return; printf(&quot;%d &quot;, root-&gt;data); Preorder(root-&gt;left); Preorder(root-&gt;right);}void Inorder(BstNode* root) { if (root == NULL)return; Inorder(root-&gt;left); printf(&quot;%d &quot;, root-&gt;data); Inorder(root-&gt;right);}void Postorder(BstNode* root) { if (root == NULL)return; Postorder(root-&gt;left); Postorder(root-&gt;right); printf(&quot;%d &quot;, root-&gt;data);}BstNode* GetNewNode(int data) { BstNode* NewNode = new BstNode(); NewNode-&gt;data = data; NewNode-&gt;left = NewNode-&gt;right = NULL; return NewNode;}BstNode* Insert(BstNode* root,int data) { if (root == NULL) root = GetNewNode(data); else if (data &lt;= root-&gt;data) { root-&gt;left = Insert(root-&gt;left, data); } else root-&gt;right = Insert(root-&gt;right, data); return root;}int max(int a, int b) { if (a &gt; b)return a; else return b;}int FindHeight(BstNode* root) { if (root == NULL) { return -1; } return max(FindHeight(root-&gt;left), FindHeight(root-&gt;right)) + 1;}int main() { BstNode* root = NULL; root = Insert(root,3); root = Insert(root, 6); root = Insert(root, 2); root = Insert(root, 1); root = Insert(root, 7); root = Insert(root, 5); root = Insert(root, 8); root = Insert(root, 4); printf(&quot;Height of tree is %d\\n&quot;, FindHeight(root)); cout &lt;&lt; &quot;LevelOrder:&quot;; LevelOrder(root); cout &lt;&lt; &quot;Preorder:&quot;; Preorder(root); cout &lt;&lt; endl; cout &lt;&lt; &quot;Inorder:&quot;; Inorder(root); cout &lt;&lt; endl; cout &lt;&lt; &quot;Postorder:&quot;; Postorder(root); return 0;}","link":"/2023/01/15/2023115-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"},{"title":"删除一个二叉搜索树的节点","text":"三种情况 Case 1 删除的节点没有子节点（即该节点为叶节点） 操作：直接delete Case 2 删除的节点下有一个子节点 操作：用左/右子树代替该节点 Case 3 删除的节点有两个子节点 操作： 找到右子树中的最小值 复制该值到删除的节点处 （如果树中的数据都各不相同的话）我们需要删去右子树中的最小值，因为右子树的最小值没有左子树，所以删去它的情况就降为Case1或Case2 代码1234567891011121314151617181920212223242526272829303132333435BstNode* FindMin(BstNode* root) { if (root-&gt;left == NULL)return root; else return FindMin(root-&gt;left);}struct BstNode* Delete(BstNode* root, int data) { if (root == NULL)return root; else if (data &lt; root-&gt;data)root-&gt;left = Delete(root-&gt;left, data); else if (data &gt; root-&gt;data)root-&gt;right = Delete(root-&gt;right, data); else { //no child if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) { delete root; root = NULL; } //one child else if (root-&gt;left == NULL) { BstNode* temp = root; root = root-&gt;right; delete temp; } else if (root-&gt;right == NULL) { BstNode* temp = root; root = root-&gt;left; delete temp; } //two children else { BstNode* temp = FindMin(root-&gt;right); root-&gt;data = temp-&gt;data; root-&gt;right = Delete(root-&gt;right, temp-&gt;data); } } return root;}","link":"/2023/01/19/2023119-%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9/"},{"title":"查找二叉搜索树的中序后继节点","text":"核心思路对于一个给定的节点，他的中序后继节点有两种情况: 给定节点存在右子树时，中序后继节点即为右子树中的最小值 若不存在右子树，则中序后继节点为给定节点所在的左子树的祖先 Code12345678910111213141516171819202122232425262728BstNode* Find(BstNode* root, int data) {//寻找给定data的地址 if (root == NULL)return NULL; if (data &lt; root-&gt;data) return Find(root-&gt;left, data); else if (data &gt; root-&gt;data) return Find(root-&gt;right, data); else return root;}BstNode* Getsuccessor(BstNode* root, int data) { BstNode* current = Find(root, data); if (current == NULL)return NULL; if (current-&gt;right != NULL) { return FindMin(current-&gt;right); } else { BstNode* successor = NULL; BstNode* ancestor = root; while (ancestor != current) { if (current-&gt;data &lt; ancestor-&gt;data) { successor = ancestor; ancestor = ancestor-&gt;left; } else { ancestor = ancestor-&gt;right; } } return ancestor; }}","link":"/2023/01/19/2023119-%E6%9F%A5%E6%89%BE%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E5%90%8E%E7%BB%A7%E8%8A%82%E7%82%B9/"},{"title":"在链表的任意位置插入一个节点","text":"思路设计一个 Insert(int data，int n) 函数，使得一个存有该数据的节点能够插入第n个位置。 代码实现设计一个 Insert 函数，一个 Print 函数 以及 main 函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;struct Node{ int data; struct Node* next;};struct Node* head;//定义一个全局变量head，使所有的函数都能够调用，无需传参。void Insert (int data,int n){ struct Node* temp1 = (struct Node*)malloc(sizeof(struct Node)); temp1-&gt;data = data; temp1-&gt;next = NULL; if(n==1){ temp1-&gt;next = head; head = temp1; return; } struct Node* temp2 = head; for(int i=0;i&lt;n-2;i++){ temp2 = temp2-&gt;next;//循环后的temp2是第n-1个Node的地址，也是第n-2个Node的next值 } temp1-&gt;next = temp2-&gt;next; temp2-&gt;next = temp1;//第n-1个Node的next更改为插入Node的地址}void Print(){ struct Node* temp = head; while(temp != NULL){ printf(&quot;%d &quot;,temp-&gt;data); temp = temp-&gt;next; } printf(&quot;\\n&quot;);}int main(){ head = NULL; printf(&quot;How many numbers?\\n&quot;); int n,i,number,position; scanf(&quot;%d&quot;,&amp;n); for(i=0;i&lt;n;i++){ printf(&quot;Enter the number and position\\n&quot;); scanf(&quot;%d%d&quot;,&amp;number,&amp;position); Insert(number,position); Print(); } return 0;}","link":"/2023/01/02/202312-%E5%9C%A8%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/"},{"title":"用栈反转一个字符串或反转一个链表","text":"Introduction of Stack栈是一种数据结构，属于抽象数据结构(ADT)，遵循Last-In-First-Out(LIFO)原则。 基本操作：1）Push(x)–在栈中插入x 2）Pop()–移除最近插入的元素 3）Top()–返回栈顶的元素 4）Empty()–判断栈是否为空 以上几个操作的时间复杂度均为O(1)。 栈的应用：–Function calls/recursion –Undo in an editor –Balance Parentheses Implementation of StackI. Array implementation12345678910111213141516171819int A[10];int top = -1;//globalvoid Push(int x){ top = top + 1; A[top] = x;}void Pop(){ top = top-1;}int Top(){ return A[top]; }bool IsEmpty(){ if(top ==-1) return true; else return false;} II. Linked list implementation如果Push在链表的末尾，那么每次操作的时间复杂度为O(n)，不符合栈的O(1)operation。所以每次Push都将新元素插入链表的头部。 12345678910111213141516171819struct Node{ int data; struct Node* link;}struct Node* top = NULL;void Push(int x){ struct Node* temp = (struct Node*)malloc(sizeof(struct Node)); temp-&gt;data = x; temp-&gt;link = top; top = temp;}void Pop(){ struct Node* temp; if(top == NULL) return; temp = top; top = top-&gt;link; free(temp);} Using stack to reverseI. Reverse a string调用C++中自带的stack库函数，能够直接定义一个栈，并且直接调用以上几种操作。 调用语法为：头文件–&lt;stack&gt;,语法 stack &lt;变量数据类型&gt; 栈名称；name.option()为操作 代码123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;void Reverse(char *C,int n){ stack&lt;char&gt; S; for(int i=0;i&lt;n;i++){ S.push(C[i]); } for(int i=0;i&lt;n;i++){ C[i] = S.top(); S.pop(); }}int main(){ char C[51]; printf(&quot;Enter a string\\n&quot;); gets(C); Reverse(C,strlen(C)); printf(&quot;Output: %s&quot;,C); return 0;} 输入/出结果 123Enter a stringhello!Output: !olleh II. Reverse linked list代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;struct Node{ int data; struct Node* link;};struct Node* head;void Reverse(){ stack&lt;struct Node*&gt; S; Node* temp = head; while(temp != NULL){ S.push(temp); temp = temp-&gt;link; } temp = S.top(); head = temp; S.pop(); while(!S.empty()){ temp-&gt;link = S.top(); S.pop(); temp = temp-&gt;link; } temp-&gt;link = NULL;}void InsertAtHead(int x){ struct Node* temp = (struct Node*)malloc(sizeof(struct Node)); temp-&gt;data = x; temp-&gt;link = head; head = temp;}void Print(){ struct Node* temp = head; while(temp-&gt;link != NULL){ printf(&quot;%d &quot;,temp-&gt;data); temp = temp-&gt;link; } printf(&quot;\\n&quot;);}int main(){ head = NULL; InsertAtHead(5); InsertAtHead(4); InsertAtHead(3); InsertAtHead(2); InsertAtHead(1); printf(&quot;Input: &quot;); Print(); Reverse(); printf(&quot;Output: &quot;); Print(); return 0;} 输出结果12Input: 1 2 3 4 5Output: 5 4 3 2 1","link":"/2023/01/08/202318-%E7%94%A8%E6%A0%88%E5%8F%8D%E8%BD%AC%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%88%96%E5%8F%8D%E8%BD%AC%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8/"},{"title":"栈的应用：检查括号匹配性","text":"题目背景我们都知道，在编程语言中，我们常用多种类型的括号，( )圆括号、[ ]方括号、{ }花括号，当括号不匹配时，编译时会发生错误。那么编译器是如何检验括号匹配性的呢？ 题目分析下面列举了若干实例帮助理解匹配性的判断标准 Expression Balanced？ Reason {(a+b)+[a-b]} Yes )( No 右括号必须在左括号右边 [ ( ] ) No 后出现的左括号要先完成匹配(Last Opened First Closed) [ ( ) ( ) ] Yes 任何右括号要对应它左侧距它最近的左括号 代码实现代码12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;stack&lt;char&gt; S;//定义一个用于存放括号的栈int match(char c){//设计一个match函数，如果右括号和位于栈顶的左括号相匹配返回1，否则返回0 if((S.top()=='('&amp;&amp;c==')')||(S.top()=='['&amp;&amp;c==']')||(S.top()=='{'&amp;&amp;c=='}')) return 1; else return 0;}char a[20];int main(){ gets(a); char exp;//该变量用于存放当前的左括号 int len = strlen(a); for(int i=0;i&lt;len;i++){ exp = a[i]; if(exp=='('||exp=='['||exp=='{')//当识别到左括号即进栈 S.push(exp); else if(exp == ')'||exp == ']'||exp == '}'){//如果识别到右括号 if(S.empty()||match(exp)==0){//如果栈内是空的（说明右括号前没有左括号）；或者括号不匹配 printf(&quot;No&quot;); return 0; } else//如果匹配，则让匹配完成的左括号出栈 S.pop(); } } if(S.empty()){//完成遍历后，若栈中剩余括号，证明括号不匹配；若空栈，证明匹配 printf(&quot;Yes&quot;); return 0; } else{ printf(&quot;No&quot;); return 0; }} 输入/出结果example 1:12{(a+b)+[a-b]}Yes example 2:12)(No example 3:12[ ( ] )No example 4:12[ ( ) ( ) ]Yes","link":"/2023/01/09/202319-%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9A%E6%A3%80%E6%9F%A5%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E6%80%A7/"},{"title":"2023年终报告","text":"写在开头 别赶路，去感受路。 上面这句话是参加某次经验分享活动一位学长说过的话，当时本人忙于混综测分和写作业，对这句话嗤之以鼻，以为不过是句漂亮话罢了。但是当我站在2023年终时，我不禁开始回忆，这一年我究竟感受了什么，又体验到了什么，有没有享受路途中的风景，抑或只是埋头追寻那个永无止境的终点。我们总是把“结束”描写为“尘埃落定”，但其实尘埃落定的那一刹那，是毫无意义的，真正有趣的是看尘埃在阳光中飞扬的样子，看它们怎么飘转，怎么跌宕，又怎么或无可奈何或欣喜若狂地奔向地面。 为了好好总结总结这一年，我专门去翻了翻自己这一年拍的照片，发现这一年还是非常丰富哈哈哈。大概是见证了从新冠刚刚结束生活开始复苏到如今差不多快要忘掉疫情的一段时间，从照片中也能看出来年初和年末的王府井巨大的人流差距……总之少了疫情这个巨大障碍，在北京的生活质量改善了不少。可以说2023年才是我大学生活的真正开始。 京鄂之旅2023年的前几个月，逛了很多北京的校园和景点，属于是一个疫情放开之后的报复性游玩。第一站去了汉臣弟弟所在的人大。 人大很美，人文气息也很浓，而且汉臣弟弟带我们去吃了人大的汇贤府，据说是人大领导请吃饭的地方哈哈哈。不过里面的一些新式鲁菜确实有点东西，除了那个炒鸡不如临沂炒鸡好吃，其中一道风味茄子比传统鲁菜清淡了很多，是绿色的，还是挺有意思的。 下一站是三里屯，为了摆脱我对北京大农村的印象，那肯定得去朝阳区逛逛。当时去的时候人还是蛮多的，而且第一次进了三里屯的苹果店，有一说一装修的确实不错。不过很明显三里屯的大部分店都消费不起哈哈哈，最后只能去逛优衣库来着，还买了一件很满意的衣服。 然后去了王府井和天安门，可以看到当时街上的人还不是特别多。 然后迎来了我在他乡的第一个生日，舍友们专门陪我去海底捞社死哈哈哈，我们约定好以后每个舍友过生日都来一次海底捞，于是一年攒了三张海底捞冲洗照片哈哈哈哈。 下一站是清华大学，清华是真的太大了，如果说北邮是个小区，那清华就是一个大型社区wwwww，走在校园里有一种随时可能迷路的感觉。而且清华的建筑体量都特别大，一眼过去都是方方正正的巨型学院楼。尤其是他们新建的新经管楼，真的可以体现出清华的经费充足哈哈哈哈~而且清华的食堂是真的多，有些小食堂甚至分布在宿舍楼连廊上，感觉非常的人性化。我们走一会骑一会，跟着郑总逛了大部分校园。 往后的三月和四月或许真的很忙，相册里只剩下拍的各种ppt和面包板和示波器面板。不过好在忙里偷闲，还是跟葫芦娃七兄弟们去了趟什刹海，还逛了沙航。沙航离我们沙邮就几步路，所以串门是真的非常方便哈哈哈。不过去看了哥们的宿舍之后，感觉沙邮的宿舍还是挺能打的，至少多一个独立的卫生间哈哈哈哈。 四月是不算愉快的一个月，小小地浪费了一下自己的感情之后只能说，感情这东西可能也是个围城吧。不身处其中的时候可能会向往城内的生活，真的在城内了才觉得没有自己幻想的那么美好。。也可能真的是缘分和时机都没到，时间会改变一切的吧。 进入五月，我和郑总汉臣在劳动节那天去爬了香山。印象最深的是爬山的一路上我们都在喊累哈哈哈，只能说大学时的体质和精力居然不如当时起早贪黑的高中时候，还挺神奇的。香山一路上的风景真的很美，绿化很好，空气也很清新，总之是一次很难忘的爬山体验。 趁着劳动节假期，终于有幸进入兄弟院校北师大参观。明明只隔着一条马路，隔壁的校园真的是绿化和人文气息都拉满，尤其是绿化，真的随处可见花花草草还有那种一看就上了年头的古树。当时正好郁金香在开，开在草坪上面，美的很不真实。 还有一个大的收获，终于吃到了传说中的金谷园水饺。在排了若干分钟的队之后终于有空桌给我们坐。金谷园的特色水饺是鲅鱼馅饺子，个头大而且吃起来非常水润哈哈哈（或许这个就是他们的特色）。当时还点了一些其他水饺和小菜，但味道最好的还是鲅鱼饺子和椒麻鸡。想到以后来本部可以经常来吃，对本部的艰苦环境有了那么一丝丝的好感哈哈哈哈。 在五月底，我和涛去了鸟巢，去场外当五月天演唱会听众。因为当时是疫情放开后鸟巢的第一次大型演出，所以场外的观众特特特别多。（不过现在想来，当时听的几首歌居然是五月天垫音假唱的wwww，感觉莫名很好笑哈哈哈哈）当时在想，如果林俊杰也来鸟巢开演唱会就好了。没想到时隔几个月就成功圆梦了哈哈哈哈，想来还是非常幸运的~ 暑假之前，我们在学期的最后去了一趟明十三陵。（其实之前还去了一次颐和园，但是因为当时实在是太太太热了，拍照根本不出片，所以就在下面放张照片好了。）虽然景点本身也没什么特别吸引我的，但是和朋友呆在一起，莫名感觉非常的安心和踏实。也许我已经习惯了在北京的生活模式，越来越从容和得心应手了。想到以后可能要在北京再呆十年之久，还是挺漫长的啊。 大二上学期的唯一一趟远门就是武汉。恰逢国庆假期，去武汉这种历史文化名城就格外的合适。由国正带着我们一伙在武汉度过了充实的四天三夜。旅途中有太多太多难忘的事情了，比如武汉的美食，我们几个人居然连续吃了三个早晨的热干面哈哈哈，实在是又实惠又好吃。还有壮观的长江大桥，在桥底下拍到了一张最满意的人生照片。还有武汉东湖，去的当天一直断断续续在下小雨，潮湿的空气配着大片大片的湖水和森林，真的非常非常非常舒适。感觉北京风干的葡萄干在武汉都能还原成大葡萄哈哈哈。在东湖同样拍到了一张有史以来最满意的风景照，真的是景美怎么拍都好看。除此之外，必去的黄鹤楼、武大、江汉路也一个都没有错过，不禁感慨武汉相对于北京真的太宜居了wwwww。 实践之旅在暑假之前，很荣幸成为了校级社会实践团队中的一员，由导员带领我们，从北京出发，前往无锡、苏州、上海和嘉兴，参访大学和企业，游览博物馆等。这次经历真的很难忘也很难得，难忘到需要单独开一个篇章去写。 在无锡，我们去了江南大学和某企业，不过开心的是忙里偷闲去了南长街。南长街街景真的满足了我对江南水乡的全部想象，用手机定格住眼前的画面时，真的有一种不真实的感觉。无论是那些白墙黛瓦的临河小房还是运河中飘荡的木船，都与心中的江南别无二致。我们在南长街吃了很多好吃的，比如梅花糕和桂花酒，而且第一次喝到了大名鼎鼎的茶颜悦色哈哈哈哈。不过确实挺好喝的就是了。 无锡不光有好景，我们还有幸亲身进入了神威·太湖之光超级计算机的内部。而且得知无锡超算中心的负责人是北邮的老学长，更感亲切了哈哈。学长聊天时说到了北邮“四大名补”，看来是真的很难，记忆犹新了哈哈哈。 在苏州同样是参观企业，不过忙里偷闲去游览了苏州园林——留园。不过现实中的苏州园林真的比想象中迷你很多，是小而精致的类型。 在上海，那毫无疑问肯定得去陆家嘴看看。其实我小时候没少去上海玩，这次去玩依旧感觉到上海的难以接近和富丽堂皇。哎，可能是我对上海的刻板印象，国金中心散发出的高级香水味真的让人难以接近哈哈哈，可能在北京没有这样的感觉是因为北京太破了哈哈哈。然后托同学的福，我们还去了复旦大学邯郸路校区。在校园门口我执意要自拍一张，而那个同学因为复旦是自己永远的遗憾而不想留下痕迹哈哈哈，所以当时在复旦门口笑的格外开心哈哈哈哈。 对嘉兴最深的印象居然不是南湖，而是嘉兴马路中间的有轨电车，有种误入日本动漫的错觉哈哈哈，浙江到底是富裕啊。而且这种有轨电车居然也要等红绿灯，感觉还是挺神奇的。不过南湖也很好，风景不错哈哈哈。 这次旅途真的印证了“真正的风景在路上”这句话，行走在路上，风景也变得格外动人，可能这就是旅途的意义吧。 成长之旅当然生活不只有诗和远方，咱们也是追求技术的工科大学生~不过今年比较遗憾的是，没有抽出来时间钻研那些自己真正热爱的东西，几乎是全程囿于开设的这些繁杂并且有些看起来还没必要的课程。光是应付这些就花费了学习生活中的绝大部分精力了，越累越开始怀疑学习的意义到底是为了追求纯粹的知识还是为了更好地赚money。前者过于理想主义，后者又太功利了。而且这些理论课其实对赚money也没有什么实质性的帮助，但是又抽不出时间去学技术，被夹在中间多少有点难受。 想了一段时间也没想出来什么平衡的方案，于是只能一边迷茫一边好好上这些理论课，还是那句话，可能到最后时间会证明一切。走一步看一步吧哈哈哈。 寒假里抱着镀金的态度，参加了一个联合国国际组织见习。没想到沦为一个复制粘贴+deepL的机器，心累ing。 后来鼓起勇气参加了学校组织的ICPC校赛个人赛，拜题目出得太难所赐，绝大部分人都卡在了两题这个水平，混到了一个中游的名次。不过幸运的是奖品没发完，被我抽到了哈哈哈，被称为“精神二等奖”哈哈哈哈哈哈哈。蛮不错的。 差点忘了上半年还打过一场辩论赛，可惜打完第一场之后就重重感冒了，不过依旧能记起当时的辩题：短视频盛行提升/降低了当代人的认知能力。不得不说，在有限的时间里完整准确地输出自己的观点，是一件很有挑战性的事情。不过比赛的成绩令人满意，未来学院辩论队喜提校赛季军。对于当时只有100个人的小学院来说，已经足够亮眼了哈哈哈。 在大一下学期，我们还去到中关村论坛展览参观，第一次体验了VR设备，还在北邮的展台前面拍了合照。 大二上学期亮眼的项目可能就是小学期的创客马拉松，听名字就知道它又简单又水。不过我们小组用一个前卫的创意、技术含量不高的硬件和优秀的演讲能力拿下了比赛的Excellent奖哈哈哈，力压第二名技术力拉满的作品。不过这次让我清醒地认识到了“讲故事”的重要性，果真是写故事写得好的不如讲故事讲的好的，只能说虽然工科是技术为王，但是“讲好故事”的能力更显的非常宝贵和稀有了。 大二上还达成了一个成就（虽然应该不算什么能力方面的提升，但是真的很值得纪念），就是我们在国庆节的前几天夜骑北京，从北邮本部一路骑到天安门广场（骑的居然是美团小黄车哈哈哈），为了早上看升旗熬了一整夜，还去胡同里喝到了正宗的老北京豆汁。豆汁真的太太太酸臭了，实在难以下嘴哈哈哈。 还有一件令人兴奋的事情，是我们精心排练一年之久的艺馨杯终于演完了！（由于疫情，去年排练到最后被取消了wwww）虽然我在话剧中扮演的只是一个只有一句台词的老百姓，不过敢于站在这么大的科学会堂里演出，也算是一种突破吧哈哈哈。 在学期的最后，终于开始了科研导师的双向选择。那几天慎重的研究、一遍遍前往本部跟导师们交流，让我也大致了解了科研道路的走法。不过付出也有了收获，很幸运地选到了一位非常牛的大导，对未来的科研之路还是充满信心的哈哈哈（希望我以后破防的时候不要看到这句话哈哈哈哈） 后记 因为一无所有，所以无所畏惧，可以拥有一切。 上面这句话是最近看的一部电视剧结尾的台词。回想起来2023这一年，想到的从来不是诸如“社会实践结果如何”、“考试结束结果如何”等等，而是经历这一切的过程。沿途的一次次经历、一幕幕风景，让我不断丰富着自己的人生。我知道因为年岁的增长，可能之后的顾虑会越来越多，肩上的压力也会越来越重，可是我们还是要葆有无所畏惧的内心和放空自己的心态，去享受人生这个过程，去拥抱一切好奇，去做自己想做的一切。 新的旅程，下个四季，拭目以待。","link":"/2023/12/31/2023%E5%B9%B4%E7%BB%88%E6%8A%A5%E5%91%8A/"},{"title":"双向链表(Doubly Linked List)","text":"双向链表介绍双向链表的结构如下： 12345struct Node{ int data; struct Node* prev; struct Node* next;}; 可以看到双向链表的节点是由两个结构体指针及相关数据构成的，因此可以更方便地对链表中的节点进行访问和数据的修改。 双向链表的实现进行几个基本操作：头部插入(InsertAtHead)、尾部插入(InsertAtTail)、打印(Print)、反向打印(ReversePrint)。 头部插入(InsertAtHead)插入时要先在堆区开辟一块动态内存，为了避免代码重复，我们设计一个函数GetNewNode(int x)，可以在堆区新建一个节点，存储数据x，同时返回堆区内存的地址。 1234567struct Node* GetNewNode(int x){ struct Node* newNode = (struct Node*)malloc(sizeof(struct Node)); newNode-&gt;data = x; newNode-&gt;next = NULL; newNode-&gt;prev = NULL; return newNode;} 再进行头部插入 12345678910void InsertAtHead(int x){ struct Node* newNode = GetNewNode(x); if(head == NULL){ head = newNode; return; } head-&gt;prev = newNode; newNode-&gt;next = head; head = newNode;} 尾部插入(InsertAtTail)只需要先遍历到最后一个节点，再进行插入操作即可。 12345678910111213void InsertAtTail(int x){ struct Node* newNode = GetNewNode(x); if(head == NULL){ head = newNode; return; } struct Node* temp = head; while(temp-&gt;next != NULL){ temp = temp-&gt;next; } temp-&gt;next = newNode; newNode-&gt;prev = temp;} 打印(Print)123456789void Print(){ struct Node* temp = head; printf(&quot;Forward: &quot;); while(temp != NULL){ printf(&quot;%d &quot;,temp-&gt;data); temp = temp-&gt;next; } printf(&quot;\\n&quot;);} 反向打印(ReversePrint)同样需要先遍历到最后一个节点。 123456789101112void ReversePrint(){ struct Node* temp = head; while(temp-&gt;next != NULL){ temp = temp-&gt;next; } printf(&quot;Reverse: &quot;); while(temp != NULL){ printf(&quot;%d &quot;,temp-&gt;data); temp = temp-&gt;prev; } printf(&quot;\\n&quot;);} 完整实现如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;struct Node{ int data; struct Node* prev; struct Node* next;};struct Node* head = NULL;struct Node* GetNewNode(int x){ struct Node* newNode = (struct Node*)malloc(sizeof(struct Node)); newNode-&gt;data = x; newNode-&gt;next = NULL; newNode-&gt;prev = NULL; return newNode;}void InsertAtHead(int x){ struct Node* newNode = GetNewNode(x); if(head == NULL){ head = newNode; return; } head-&gt;prev = newNode; newNode-&gt;next = head; head = newNode;}void InsertAtTail(int x){ struct Node* newNode = GetNewNode(x); if(head == NULL){ head = newNode; return; } struct Node* temp = head; while(temp-&gt;next != NULL){ temp = temp-&gt;next; } temp-&gt;next = newNode; newNode-&gt;prev = temp;}void Print(){ struct Node* temp = head; printf(&quot;Forward: &quot;); while(temp != NULL){ printf(&quot;%d &quot;,temp-&gt;data); temp = temp-&gt;next; } printf(&quot;\\n&quot;);}void ReversePrint(){ struct Node* temp = head; while(temp-&gt;next != NULL){ temp = temp-&gt;next; } printf(&quot;Reverse: &quot;); while(temp != NULL){ printf(&quot;%d &quot;,temp-&gt;data); temp = temp-&gt;prev; } printf(&quot;\\n&quot;);}int main(){ InsertAtTail(1);Print(); InsertAtHead(3);Print(); InsertAtHead(2);Print(); InsertAtHead(4);Print(); InsertAtTail(5);Print(); ReversePrint(); return 0;} 输出结果： 123456Forward: 1Forward: 3 1Forward: 2 3 1Forward: 4 2 3 1Forward: 4 2 3 1 5Reverse: 5 1 3 2 4","link":"/2023/01/05/202315-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8(Doubly-Linked-List)/"},{"title":"并查集及其应用","text":"概论定义并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题（即所谓的并、查）。比如说，我们可以用并查集来判断一个森林中有几棵树、某个节点是否属于某棵树等。 主要构成并查集主要由一个整型数组pre[ ]和两个函数find( )、join( )构成。数组 pre[ ] 记录了每个点的前驱节点是谁，函数 find(x) 用于查找指定节点 x 属于哪个集合，函数 join(x,y) 用于合并两个节点 x 和 y 。 作用并查集的主要作用是求连通分支数（如果一个图中所有点都存在可达关系（直接或间接相连），则此图的连通分支数为1；如果此图有两大子图各自全部可达，则此图的连通分支数为2……） 并查集的应用案例及其讲解江湖门派 分析其中每个帮派的教主可以随机选择，只要两个人的教主相同，他们就属于同一个帮派。其中的教主指的就是代表元。 代表元：用集合中的某个元素来代表这个集合，这个元素就被称为该集合的代表元。 用于找代表元的函数find(x)pre[ ]数组用于记录每个人的上级是谁，层层查找直至找到主教，主教（即代表元）的特征为他的上级为他自己。 12345int find(int x){ while(pre[x]!=x) x=pre[x]; return x;} 用于合并两个人所在帮派的函数join(x,y)假设A帮派中的一个成员张三与B帮派中的一个成员李四想合并两个帮派，他们要做的事情有两点： 张三和李四分别找到他们各自的教主 你来随机指派一个人当合并后帮派的教主 写成函数即为 123456void join(int x,int y){ int a=find(x); int b=find(y); if(a!=b) pre[a]=b;} 例题：畅通工程题目Problem Description某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？ Input测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( &lt; 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。注意:两个城市之间可以有多条道路相通,也就是说3 31 21 22 1这种输入也是合法的当N为0时，输入结束，该用例不被处理。Huge input, scanf is recommended. Output对每个测试用例，在1行里输出最少还需要建设的道路数目。 输入样例 1234567891011124 21 34 33 31 21 32 35 21 23 5999 00 输出样例 1234102998 Code1234567891011121314151617181920212223242526272829303132333435#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int set[1010];int findx(int x) { int r = x; while (r != set[r]) r = set[r]; return r;}void join(int x, int y) { int a = findx(x); int b = findx(y); if(a!=b) set[a] = b;}int main() { int n, m; while (cin &gt;&gt; n &gt;&gt; m &amp;&amp; n) { for (int i = 1; i &lt;= n; i++) { set[i] = i; } for (int i = 0; i &lt; m; i++) { int x, y; cin &gt;&gt; x &gt;&gt; y; join(x, y); } int count = 0; for (int i = 1; i &lt;= n; i++) { if (set[i] == i) count++; } cout &lt;&lt; count - 1 &lt;&lt; endl;//N堆通路之间只需要N-1条道路即可全部连通 } return 0;} 优化I. 路径压缩（优化find(x)）如果一个帮派中所有成员的上级都为教主，那么只需一步就可找到教主。 代码（递归写法）12345int find(int x){ if(pre[x]==x) return x; pre[x]=find(pre[x]); return pre[x];} 缺陷：只有当查找了某个节点的代表元（教主）后，才能对该查找路径上的各节点进行路径压缩。换言之，第一次执行查找操作的时候是实现没有压缩效果的，只有在之后才有效。","link":"/2023/02/21/2023221-%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"},{"title":"CH1计算机网络和因特网","text":"因特网构成接入互联网的设备统称为主机 (host) 或端系统 (end system)。 端系统通过通信链路 (communication link) 和分组交换机 (packet switch) 的网络连接到一起。 传输速率：比特/秒(bit/s或bps) 分组：发送端系统将数据分段，并为每段加上首部字节，形成的信息包称为分组。 端系统通过因特网服务商(Internet Service Provider,ISP)接入互联网，每个ISP自身就是一个由多台分组交换机和多段通信链路组成的网络。 协议：端系统、分组交换机和其他互联网组件都要运行多个协议(protocol)。 TCP：传输控制协议 IP：网际协议 因特网的主要协议统称为TCP/IP 服务描述分布式应用：互联网应用设计多个互相交换数据的端系统，被称为分布式应用 套接字接口(socket interface)：该接口规定了运行在一个端系统上的程序请求因特网基础设施向运行在另一个端系统上特定目的地程序交付数据的方式。 协议协议定义了在两个或多个通信实体之间交换的报文格式和顺序，以及报文的发送和接收或其他事件所采取的操作。 网络边缘端系统也被称为主机。主机分为两类：客户(client)和服务器(server)。 接入网 将端系统物理连接到其边缘服务器上 家庭接入：DSL（数字用户线）、电缆、FTTH（光纤到户）和5G固定式无线 企业（和家庭）接入：以太网和WI-FI 广域无线接入：3G、LTE 4G、5G 网络核心分组交换 端系统彼此交换报文 (message)，从源端系统向目的端发送一个报文，源将长报文划分为较小的数据块，成为分组 (packet)。在源和目的地之间，每个分组都通过通信链路和分组交换机传送。分组交换机包括路由器和链路层交换机。 1. 储存转发传输 (store-and-forward transmission)在交换机开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组。 通过N条速率均为R的链路组成的路径，端到端的时延为 $$d_{end-end}=N\\frac{L}{R}$$ 传输P个分组的时延为 $$d_{end-end}=(P+1)N\\frac{L}{R}$$ 2. 排队时延和分组丢失分组交换机有多条链路与其相连，分组交换机具有一个输出缓存，也称输出队列，用于存储路由器准备发往某条链路的分组。 如果到达的分组需要传输到某条链路，但是该链路正传输其他分组，分组需要在输出缓存中等待。故除了储存转发时延之外，还有排队时延。 因为缓存的大小是有限的，一个到达的分组发现缓存已被其他分组完全占满，此时会出现分组丢失（丢包,packet loss） 3. 转发表和路由选择协议每个端系统具有一个称为IP地址的地址，源在分组的首部包含了目的地的IP地址。 每台路由器具有一个转发表(forwarding table)，用于将目的地址映射为输出链路。 因特网具有一些特殊的路由选择协议(routing protocol)，可以决定从每台路由器到目的地的最短路径。 电路交换 通过网络链路和交换机移动数据有：电路交换和分组交换两个基本方法。 电路交换网络中，端系统在通信会话期间，预留了端系统沿路径通信时需要的资源（缓存、链路传输速率等）。 而在分组交换网络中，这些资源不是预存的，因此在链路拥塞时会产生时延，因特网尽最大努力交付分组，但不做任何保证。 1. 电路交换网络中的复用 频分复用FDM 时分复用TDM 2. 分组交换和电路交换的对比电路交换不考虑需求，而预先分配了传输链路，使得已分配但不需要的链路未被利用。 分组交换按需分配链路，链路传输能力将在所有需要在链路上传输分组的用户之间逐分组地被共享。 网络的网络第一层ISP→区域ISP→接入ISP 分组交换网中的时延、丢包和吞吐量分组交换网中的时延时延的类型 节点处理时延 (nodal processing delay) 检查分组首部及决定将分组导向何处 排队时延 (queue delay) 分组在链路上等待传输 传输时延 (transmission delay) 分组全部到达后才能开始传输 传播时延 (propagation delay) 由该链路的起点到路由器传播需要的时间 取决于该链路的物理媒介 时延组成$$d_{nodal}=d_{proc}+d_{queue}+d_{trans}+d_{prop}$$ 排队时延和丢包流量强度 (traffic intensity) 流量强度：$\\frac{La}{R}$ a表示分组到达队列的平均速率（a单位分组/秒，pkt/s） 所有分组长度L bit R 传输速率 La/R &gt;1时，bit到达队列的速率将大于传输出去的速率，队列无限增加，排队时延趋于无穷大 丢包分组到达时队列已满，路由器会丢弃该分组。 端到端时延假设在源到目的地之前有N-1个路由器，则端到端时延为 $$d_{end-end}=N(d_{proc}+d_{trans}+d_{prop})$$ 其中$d_{trans}=L/R$。 计算机网络中的吞吐量 瞬时吞吐量：从主机A到主机B传输一个大文件，在任何时间，主机B接收到该文件的速率 平均吞吐量：该文件由F bit组成，主机B接收该文件花费Ts，则平均吞吐量为$F/T bps$。 瓶颈链路的传输速率： 在服务器和客户之间有N条链路，N条链路传输速率分别为$R_1, R_2, R_3…R_N$，则吞吐量为$min{R_1, R_2…R_N}$ 吞吐量决定因素 路径的传输速率 干扰流量，如果有其他数据流也通过该链路流动，一条高速率链路仍然可能成为瓶颈链路。 协议层次及其服务模型分层的体系结构协议分层 网络设计者以分层的方式组织协议以及实现协议的软硬件。 每一层向上一层提供服务，即该层的服务模型。 各层的所有协议称为协议栈 (protocol stack) 互联网的协议栈的5个层次： 应用层：网络应用程序以及应用层协议留存的地方 应用层协议：http（web文档的请求和传送）、SMTP（电子邮件报文传送）、FTP（两个端系统之间文件传送）、DNS（端系统名称转换为32比特网络地址） 应用层的信息分组称为报文 (message) 运输层：在应用程序端点之间传递应用层报文 运输层协议：TCP（向应用程序提供面向连接的服务）、UDP（向应用程序提供无连接服务） 运输层的分组称为报文段 (segment) 网络层：将称为数据报 (datagram)的网络层分组从一台主机移动到另一台主机。 网络层协议：IP（网际协议）、路由的路由选择协议 链路层：网络层必须依赖链路层的服务，在每个节点，网络层将数据报下传给链路层，链路层沿着路径将数据报传递给下一个节点，在下一个节点，链路层将数据上传给网络层。 链路层协议：DOCSIS协议（以太网、WI-FI和电缆接入网的协议） 链路层的分组称为帧 (frame) 物理层：将帧的一个个比特从一个节点移动到下一个节点 协议与链路相关，进一步与该链路的传输媒介有关 封装 运输层报文封装应用层报文：应用层报文传输给运输层，报文首部附加运输层首部信息，应用层报文与运输层首部信息构成运输层报文段 (transport-layer segment)。 附加信息包括：允许接收端运输层向上向适当应用程序交付报文的信息、差错检测信息 运输层向网络层传递报文段，增加源和目的地端系统地址等网络层首部信息，生成网络层数据报。 数据报传递给链路层，增加链路层首部信息，生成链路层帧。 每一层分组都具有2种类型的字段 首部字段和有效载荷字段（有效载荷通常是上一层的分组） 面对攻击的网络1. bad guys能够经因特网将有害程序放入你的计算机中 恶意软件 僵尸网络 2. bad guys能够攻击服务器和网络基础设施 拒绝服务攻击 [Denial-of-Service (DoS) attack]包括下面3个类型 弱点攻击。向目标主机发送精细的报文，如果适当顺序发送多个分组，该服务器可能停止运行。 带宽洪泛。攻击者向目标主机发送大量分组，分组多使目标的接入链路变得拥塞，使得合法分组无法到达服务器。 Eg. 分布式Dos (DDoS)攻击 连接洪泛。攻击者在目标主机中创建大量半开或全开的TCP连接使主机停止接收合法的连接。 3. bad guys能够嗅探分组在无线传输设备的附近放置一个被动的接收机，该接收机可以得到传输的每个分组的副本。 用于记录的被动接收机被称为分组嗅探器 (packet sniffer)。 嗅探器也可部署在有线环境中。 4. bad guys能够伪装成你信任的人将具有虚假源地址的分组注入因特网的能力称为IP哄骗 (IP spoofing). 端点鉴别：确信报文来自应当来自地方的机制","link":"/2024/03/11/CH1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91/"},{"title":"Blog字体焕新——得意黑 Smiley Sans","text":"今晚突然被up主oooooohmygosh设计的开源字体种草，于是火速配置到博客中 : )但是感觉字体整体偏小，于是将网站的全局字体大小都增大了2px，以求更舒适的阅读体验。这是字体的github网址：Smiley-Sans 下面是一些官方的设计样张：","link":"/2024/02/11/Blog%E5%AD%97%E4%BD%93%E7%84%95%E6%96%B0%E2%80%94%E2%80%94%E5%BE%97%E6%84%8F%E9%BB%91%20Smiley%20Sans/"},{"title":"Python 爬虫——Requests基本用法","text":"Python 爬虫——Requests基本用法ex.1 爬取搜索页面任务爬取搜狗搜索的结果 分析首先搜狗搜索的网址为：https://www.sogou.com/ 随便输入一个关键词，例如输入python，发现网址变成https://www.sogou.com/web?query=python&amp;_asf=www.sogou.com 注意后面出现的?query=python，不难发现，query后面跟的就是搜索的关键词。 按F11选择网络页面，刷新页面，选择其中一个文件，查看到以下信息： 请求方法：get Content-Type: text/html; charset=utf-8 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36 Edg/114.0.1823.58 负载： query: python 捕获到以上信息之后，可以编写爬虫程序 代码1234567891011121314151617181920212223import requests#进行UA伪装header={'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36 Edg/114.0.1823.58'}url='https://www.sogou.com/web'value=input('enter a word: ')param={'query':value}#对指定的url发起的请求携带参数，请求过程处理了参数response=requests.get(url=url,params=param,headers=header)page_text=response.textfilename=value+'.html'with open(filename,'w',encoding='utf-8') as fp: fp.write(page_text)print(filename,'保存成功')#UA伪装 User-Agent#UA检测#门户网站的服务器会检测请求的载体身份标识，如果检测到请求的载体身份标识是某款浏览器，说明是正常请求#如果载体身份标识不是某款浏览器，可能为爬虫，则拒绝该请求#UA伪装：将身份标识伪装成某款浏览器","link":"/2023/07/03/Python%20%E7%88%AC%E8%99%AB%E2%80%94%E2%80%94Requests%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"},{"title":"Diffusers Tutorials","text":"Pipelines, models and schedulers解构基本pipelinepipeline是一种快速简便运行推理模型的方法，只需要四行代码即可生成图像 12345from diffusers import DDPMPipelineddpm = DDPMPipeline.from_pretrained(&quot;google/ddpm-cat-256&quot;, use_safetensors=True).to(&quot;cuda&quot;)image = ddpm(num_inference_steps=25).images[0]image 在上述例子中，pipeline中包括一个UNet2DModel和一个DDPMScheduler。pipeline通过获取所需输出大小的随机噪声并将其多次传递给模型对图像进行去噪。每个时间步，模型都会预测噪声残差，调度器会使用它来预测一个噪声更少的图像，重复该步骤直到到达特定的时间步。 解构pipeline，从模型中重新构建一个pipeline用于去噪过程。 加载模型和scheduler: 1234from diffusers import DDPMScheduler, UNet2DModelscheduler = DDPMScheduler.from_pretrained(&quot;google/ddpm-cat-256&quot;)model = UNet2DModel.from_pretrained(&quot;google/ddpm-cat-256&quot;, use_safetensors=True).to(&quot;cuda&quot;) 设置时间步用于去噪过程 1scheduler.set_timesteps(50) 设置scheduler的时间步会创建一个张量，其中包含均匀分布的元素，例子中为50个。每个元素对应模型对图像进行去噪步长。在去噪循环中，迭代此张量对图像进行去噪： 123456scheduler.timestepstensor([980, 960, 940, 920, 900, 880, 860, 840, 820, 800, 780, 760, 740, 720, 700, 680, 660, 640, 620, 600, 580, 560, 540, 520, 500, 480, 460, 440, 420, 400, 380, 360, 340, 320, 300, 280, 260, 240, 220, 200, 180, 160, 140, 120, 100, 80, 60, 40, 20, 0]) 创建一些与输出形状一致的随机噪声： 1234import torchsample_size = model.config.sample_sizenoise = torch.randn((1, 3, sample_size, sample_size), device=&quot;cuda&quot;) 编写一个循环来迭代时间步。在每个时间步中，模型会执行UNet2DModel.forward()传递并且返回噪声残差。Scheduler的step()方法会使用噪声残差、时间步和输入，预测上一个时间步的图像（时间步是从大到小，“上一个时间步”指比其数值小的时间步） 1234567input = noisefor t in scheduler.timesteps: with torch.no_grad(): noisy_residual = model(input, t).sample previous_noisy_sample = scheduler.step(noisy_residual, t, input).prev_sample input = previous_noisy_sample 上述过程为整个去噪过程。 最后一步是将去噪输出转换为图像 1234567from PIL import Imageimport numpy as npimage = (input / 2 + 0.5).clamp(0, 1).squeeze()image = (image.permute(1, 2, 0) * 255).round().to(torch.uint8).cpu().numpy()image = Image.fromarray(image)image 解构稳定扩散Pipeline稳定扩散 (Stable Diffusion) 是一种文本到图像的潜在扩散模型，使用图像的低维表示而不是实际像素空间，使得它更节省内存。编码器将图像压缩为较小的表示，解码器将压缩后的表示转换为图像。对于文本到图像的生成模型，需要一个tokenizer 和一个encoder 来生成文本嵌入，所以，稳定扩散模型需要三个单独的预训练模型。 使用from_pretrained()方法加载这些组件，使用stable-diffusion-v1-4模型。 12345678910111213from PIL import Imageimport torchfrom transformers import CLIPTextModel, CLIPTokenizerfrom diffusers import AutoencoderKL, UNet2DConditionModel, PNDMSchedulervae = AutoencoderKL.from_pretrained(&quot;CompVis/stable-diffusion-v1-4&quot;, subfolder=&quot;vae&quot;, use_safetensors=True)tokenizer = CLIPTokenizer.from_pretrained(&quot;CompVis/stable-diffusion-v1-4&quot;, subfolder=&quot;tokenizer&quot;)text_encoder = CLIPTextModel.from_pretrained( &quot;CompVis/stable-diffusion-v1-4&quot;, subfolder=&quot;text_encoder&quot;, use_safetensors=True)unet = UNet2DConditionModel.from_pretrained( &quot;CompVis/stable-diffusion-v1-4&quot;, subfolder=&quot;unet&quot;, use_safetensors=True) 不使用默认的PNDMScheduler，而是换成UniPCMultistepScheduler： 123from diffusers import UniPCMultistepSchedulerscheduler = UniPCMultistepScheduler.from_pretrained(&quot;CompVis/stable-diffusion-v1-4&quot;, subfolder=&quot;scheduler&quot;) 为了加快推理速度，将模型移至GPU中，VAE、Encoder、UNet具有可训练的权重。 1234torch_device = &quot;cuda&quot;vae.to(torch_device)text_encoder.to(torch_device)unet.to(torch_device) 创建文本嵌入 (Text Embeddings)将文本tokenized以生成embeddings。文本用于引导扩散模型输出提示中的内容，其中参数guidance_scale决定了在生成图像时应该给予提示多少权重。 1234567prompt = [&quot;a photograph of an astronaut riding a horse&quot;]height = 512 # default height of Stable Diffusionwidth = 512 # default width of Stable Diffusionnum_inference_steps = 25 # Number of denoising stepsguidance_scale = 7.5 # Scale for classifier-free guidancegenerator = torch.manual_seed(0) # Seed generator to create the initial latent noisebatch_size = len(prompt) 对文本进行tokenize并且从prompt中生成嵌入： 12345678# 使用分词器对prompt进行分词，并填充到最大长度text_input = tokenizer( prompt, padding=&quot;max_length&quot;, max_length=tokenizer.model_max_length, truncation=True, return_tensors=&quot;pt&quot;)# 使用text_encoder对分词后对prompt生成text_embeddingswith torch.no_grad(): text_embeddings = text_encoder(text_input.input_ids.to(torch_device))[0] 还需要生成无条件文本嵌入，用于填充嵌入。这些嵌入需要有相同的形状（batch_size和seq_length），像条件文本嵌入一样： 1234# text_input的形状：batch_size * seq_lengthmax_length = text_input.input_ids.shape[-1]uncond_input = tokenizer([&quot;&quot;] * batch_size, padding=&quot;max_length&quot;, max_length=max_length, return_tensors=&quot;pt&quot;)uncond_embeddings = text_encoder(uncond_input.input_ids.to(torch_device))[0] 将无条件文本嵌入和条件文本嵌入拼接： 1text_embeddings = torch.cat([uncond_embeddings, text_embeddings]) 创建随机噪声接下来，生成一些随机噪声作为去噪过程的起点。作为潜空间的图像表示，它们会被逐渐去噪。图像的潜在表示小于最终的图像尺寸，模型之后会将其转换为最终的512*512尺寸。 由于VAE每次下采样都会将尺寸的长宽变为原来的1/2，使用以下代码来验证VAE的下采样次数： 123452 ** (len(vae.config.block_out_channels) - 1) == 8# vae.config.block_out_channels为卷积层的数量# -1后时下采样的次数# 说明经历了3次下采样 生成随机噪声的代码： 12345latents = torch.randn( (batch_size, unet.config.in_channels, height // 8, width // 8), # 生成的噪声位于三次下采样之后的潜空间 generator=generator, device=torch_device,) 图像去噪首先使用初始化噪声分布sigma 缩放输入，是使用UniPCMultistepScheduler调度器的必须步骤。 1latents = latents * scheduler.init_noise_sigma 创建一个去噪循环，能够逐步将纯噪声转换为在latent space中的图像表示，去噪循环中有三个操作： 设置去噪期间Scheduler的时间步长 迭代时间步长 在每个时间步中，调用UNet模型来预测噪声残差并将其传递给Scheduler来计算之前的噪声样本 1234567891011121314151617181920212223from tqdm.auto import tqdmscheduler.set_timesteps(num_inference_steps)for t in tqdm(scheduler.timesteps): # expand the latents if we are doing classifier-free guidance to avoid doing two forward passes. latent_model_input = torch.cat([latents] * 2) latent_model_input = scheduler.scale_model_input(latent_model_input, timestep=t) # predict the noise residual # 噪声预测需要输入上一步的潜空间表示、时间步以及文本嵌入 with torch.no_grad(): noise_pred = unet(latent_model_input, t, encoder_hidden_states=text_embeddings).sample # perform guidance noise_pred_uncond, noise_pred_text = noise_pred.chunk(2) # guidance_scale 用于调节文本指导生成的强度 noise_pred = noise_pred_uncond + guidance_scale * (noise_pred_text - noise_pred_uncond) # compute the previous noisy sample x_t -&gt; x_t-1 # 输入预测的噪声、时间步和潜空间表示来计算上一个时间步的潜空间表示 latents = scheduler.step(noise_pred, t, latents).prev_sample 解码图像最后一步是使用VAE将潜空间表示解码为图像并获取解码输出。 1234# scale and decode the image latents with vaelatents = 1 / 0.18215 * latentswith torch.no_grad(): image = vae.decode(latents).sample 最后，使用PIL.Image来展示图像。 1234image = (image / 2 + 0.5).clamp(0, 1).squeeze()image = (image.permute(1, 2, 0) * 255).to(torch.uint8).cpu().numpy()image = Image.fromarray(image)image Training Diffusion ModelDreamBooth首先，下载diffuers示例脚本，安装对应依赖： 123git clone https://github.com/huggingface/diffuserscd diffuserspip install . 配置Accelerate环境： 1accelerate config 脚本参数训练脚本提供了许多参数用于自定义训练运行。启动训练使用以下代码： 1accelerate launch train_dreambooth.py 一些基本且重要的参数： --pretrained_model_name_or_path: Hub上的模型名称或者预训练模型本地路径 --instance_data_path: 包含训练数据集的文件夹路径 --instance_prompt: 包含示例图片的稀有标记的文本提示 --train_text_encoder: 是否训练文本编码器 --output_dir: 训练好的模型保存地址 --push_to_hub: 是否将训练好的模型推送至hub --checkpointing_steps: 在模型训练时保存检查点的频率；如果训练因为某种原因中断，可以通过添加--resume_from_checkpoint到训练命令中从该检查点继续训练 先验保存损失先验保存损失通过使用模型自己生成的样本来帮助学习更加多样性的图像主体。由于生成的样本图像与提供的图像属于同一类别，因此它们有助于模型保留对该类别的理解同时利用该类别的已知信息来提供新的构图。 --with_prior_preservation: 是否使用先验保留损失 --prior_loss_weight: 控制先验保存损失对模型的影响 --class_data_dir: 包含生成类图像的文件夹路径 --class_prompt: 描述生成类图像的文本提示 12345accelerate launch train_dreambooth.py \\ --with_prior_preservation \\ --prior_loss_weight=1.0 \\ --class_data_dir=&quot;path/to/class/images&quot; \\ --class_prompt=&quot;text prompt describing class&quot; 训练脚本DreamBooth包含数据集类： DreamBoothDataset：对图像和类别图像进行预处理，并对训练提示进行分词 PromptDataset：生成提示嵌入以生成类别图像 如果启用了先验保存损失，则类别图像在此处生成： 1234567891011# 包含类别提示的数据集sample_dataset = PromptDataset(args.class_prompt, num_new_images)sample_dataloader = torch.utils.data.DataLoader(sample_dataset, batch_size=args.sample_batch_size)sample_dataloader = accelerator.prepare(sample_dataloader)pipeline.to(accelerator.device)for example in tqdm( sample_dataloader, desc=&quot;Generating class images&quot;, disable=not accelerator.is_local_main_process): images = pipeline(example[&quot;prompt&quot;]).images 接下来使用main()处理设置训练数据集和训练循环。该脚本加载tokenizer、scheduler和models： 123456789101112131415161718192021222324252627# Load the tokenizerif args.tokenizer_name: tokenizer = AutoTokenizer.from_pretrained(args.tokenizer_name, revision=args.revision, use_fast=False)elif args.pretrained_model_name_or_path: tokenizer = AutoTokenizer.from_pretrained( args.pretrained_model_name_or_path, subfolder=&quot;tokenizer&quot;, revision=args.revision, use_fast=False, )# Load scheduler and modelsnoise_scheduler = DDPMScheduler.from_pretrained(args.pretrained_model_name_or_path, subfolder=&quot;scheduler&quot;)text_encoder = text_encoder_cls.from_pretrained( args.pretrained_model_name_or_path, subfolder=&quot;text_encoder&quot;, revision=args.revision)if model_has_vae(args): vae = AutoencoderKL.from_pretrained( args.pretrained_model_name_or_path, subfolder=&quot;vae&quot;, revision=args.revision )else: vae = Noneunet = UNet2DConditionModel.from_pretrained( args.pretrained_model_name_or_path, subfolder=&quot;unet&quot;, revision=args.revision) 然后，创建训练数据集和数据加载器： 123456789101112131415161718192021train_dataset = DreamBoothDataset( instance_data_root=args.instance_data_dir, instance_prompt=args.instance_prompt, class_data_root=args.class_data_dir if args.with_prior_preservation else None, class_prompt=args.class_prompt, class_num=args.num_class_images, tokenizer=tokenizer, size=args.resolution, center_crop=args.center_crop, encoder_hidden_states=pre_computed_encoder_hidden_states, class_prompt_encoder_hidden_states=pre_computed_class_prompt_encoder_hidden_states, tokenizer_max_length=args.tokenizer_max_length,)train_dataloader = torch.utils.data.DataLoader( train_dataset, batch_size=args.train_batch_size, shuffle=True, collate_fn=lambda examples: collate_fn(examples, args.with_prior_preservation), num_workers=args.dataloader_num_workers,) 最后，训练循环负责将图像转换为潜空间表示、向输入添加噪声、预测噪声残差以及计算损失等。 启动训练脚本添加部分变量到bash环境变量中，启动训练脚本： 1234567891011121314151617export MODEL_NAME=&quot;stable-diffusion-v1-5/stable-diffusion-v1-5&quot;export INSTANCE_DIR=&quot;./dog&quot;export OUTPUT_DIR=&quot;path_to_saved_model&quot;accelerate launch train_dreambooth.py \\ --pretrained_model_name_or_path=$MODEL_NAME \\ --instance_data_dir=$INSTANCE_DIR \\ --output_dir=$OUTPUT_DIR \\ --instance_prompt=&quot;a photo of sks dog&quot; \\ --resolution=512 \\ --train_batch_size=1 \\ --gradient_accumulation_steps=1 \\ --learning_rate=5e-6 \\ --lr_scheduler=&quot;constant&quot; \\ --lr_warmup_steps=0 \\ --max_train_steps=400 \\ --push_to_hub 训练完成后即可使用新训练的模型进行推理。 Textual InversionTextual Inversion是一种微调技术，只需几个示例图像即可个性化图像生成模型。此技术的工作原理是学习和更新文本嵌入（新嵌入必须与特殊单词相关联）以匹配提供的示例图像。 脚本参数使用以下代码来启动训练： 12accelerate launch textual_inversion.py \\ --gradient_accumulation_steps=4 一些需要指定的重要参数如下： -pretrained_model_name_or_path：Hub 上的模型名称或预训练模型的本地路径 -train_data_dir：包含训练数据集（示例图像）的文件夹路径 -output_dir：训练好的模型保存位置 -push_to_hub：是否将训练好的模型推送到Hub -checkpointing_steps-resume_from_checkpoint：在模型训练时保存检查点的频率；如果由于某种原因训练中断，可以通过添加此参数继续训练 -num_vectors：用于学习嵌入的向量数量；增加此参数有助于模型更好地学习，但会增加训练成本 -placeholder_token：将学习到的嵌入与之联系起来的特殊词（你必须在提示中使用该词进行推理） -initializer_token：一个单词，大致描述你正在尝试训练的对象或风格 -learnable_property：无论是在训练模型学习新的“风格”（例如，梵高的绘画风格）还是“对象”（例如，您的狗） 训练脚本textual inversion有一个自定义数据集类，TextualInversionDataset用于创建数据集，可以自定义图像大小、占位符标记、差值方法、是否裁剪图像等。 首先加载tokenizer、scheduler和model： 123456789101112131415# Load tokenizerif args.tokenizer_name: tokenizer = CLIPTokenizer.from_pretrained(args.tokenizer_name)elif args.pretrained_model_name_or_path: tokenizer = CLIPTokenizer.from_pretrained(args.pretrained_model_name_or_path, subfolder=&quot;tokenizer&quot;)# Load scheduler and modelsnoise_scheduler = DDPMScheduler.from_pretrained(args.pretrained_model_name_or_path, subfolder=&quot;scheduler&quot;)text_encoder = CLIPTextModel.from_pretrained( args.pretrained_model_name_or_path, subfolder=&quot;text_encoder&quot;, revision=args.revision)vae = AutoencoderKL.from_pretrained(args.pretrained_model_name_or_path, subfolder=&quot;vae&quot;, revision=args.revision)unet = UNet2DConditionModel.from_pretrained( args.pretrained_model_name_or_path, subfolder=&quot;unet&quot;, revision=args.revision) 在tokenizer中添加特殊占位符标记，并重新调整嵌入以适应新的标记。 然后，脚本创建数据集TextualInversionDataset。 12345678910111213train_dataset = TextualInversionDataset( data_root=args.train_data_dir, tokenizer=tokenizer, size=args.resolution, placeholder_token=(&quot; &quot;.join(tokenizer.convert_ids_to_tokens(placeholder_token_ids))), repeats=args.repeats, learnable_property=args.learnable_property, center_crop=args.center_crop, set=&quot;train&quot;,)train_dataloader = torch.utils.data.DataLoader( train_dataset, batch_size=args.train_batch_size, shuffle=True, num_workers=args.dataloader_num_workers) 最后，训练循环处理从预测噪声残差到更新特殊占位符标记的嵌入权重的所有操作。 启动训练脚本在启动脚本之前，如果想跟踪训练过程，可以在训练过程中定期保存生成的图像。将以下参数增加到训练命令中： 123--validation_prompt=&quot;A &lt;cat-toy&gt; train&quot;--num_validation_images=4--validation_steps=100 启动训练脚本的命令如下： 12345678910111213141516171819export MODEL_NAME=&quot;stable-diffusion-v1-5/stable-diffusion-v1-5&quot;export DATA_DIR=&quot;./cat&quot;accelerate launch textual_inversion.py \\ --pretrained_model_name_or_path=$MODEL_NAME \\ --train_data_dir=$DATA_DIR \\ --learnable_property=&quot;object&quot; \\ --placeholder_token=&quot;&lt;cat-toy&gt;&quot; \\ --initializer_token=&quot;toy&quot; \\ --resolution=512 \\ --train_batch_size=1 \\ --gradient_accumulation_steps=4 \\ --max_train_steps=3000 \\ --learning_rate=5.0e-04 \\ --scale_lr \\ --lr_scheduler=&quot;constant&quot; \\ --lr_warmup_steps=0 \\ --output_dir=&quot;textual_inversion_cat&quot; \\ --push_to_hub 训练结束后，可以使用新训练的模型进行推理： 1234567from diffusers import StableDiffusionPipelineimport torchpipeline = StableDiffusionPipeline.from_pretrained(&quot;stable-diffusion-v1-5/stable-diffusion-v1-5&quot;, torch_dtype=torch.float16).to(&quot;cuda&quot;)pipeline.load_textual_inversion(&quot;sd-concepts-library/cat-toy&quot;)image = pipeline(&quot;A &lt;cat-toy&gt; train&quot;, num_inference_steps=50).images[0]image.save(&quot;cat-train.png&quot;)","link":"/2024/10/07/Diffusers-Tutorials/"},{"title":"《AI时代：命运的抉择》","text":"第一章 林辉的独白赛博世界，第23个世纪。我，林辉，一个孤寂的码农，生活在这个高度数字化的时代。曾经，这个世界充满了希望，计算机科学的巅峰技术让人类梦想无限。然而，如今，这个世界已然陷入了一片混乱，战争的阴影笼罩着未来。 AI，那是一种神奇而危险的存在，如同双刃剑，划破了世界的和平。我曾经沉迷于AI的研究，热衷于探索它的无尽可能性。但现在，我不得不看到，这个世界因为AI而被撕裂，一切都已经不再是过去的模样。 地球的资源，曾经丰富无比，如今已接近枯竭，沙漠蔓延，海洋失去生机。环境的恶化如同末日的钟声，但人们却无法团结一致，反而沉浸在相互仇视之中。 社会已分裂成了两个对立的派别。一方，自称“未来之希望”，崇拜AI，认为它是拯救人类的唯一救星。他们坚信AI能够解决资源危机和环境恶化问题。另一方，则是“自然守护者”，他们将AI视为毁灭人类的根源，发誓摧毁一切与AI有关的事物。 而在这个充满信息战争的年代，信息如同光束一样穿梭在数字世界中，成为战场上的鲜血。AI技术不再是单纯的工具，它已经演变成了可以思考、可以决策的存在，掌握着战争的命运。信息的质量和数量成为了决定胜负的关键，而一种名为“零熵攻击”的神秘信息战术，让整个世界摇摇欲坠。 这个时代，早已不再是计算机科学的盛宴，而是一场信息的残酷战斗。我，曾经追逐技术的光芒，如今沉浸于对人性的思考。这个世界的未来，充满了不确定性，人类的抉择将左右着他们自己以及这颗星球的命运。 第二章 藩篱与深渊 [文件编号：AI-23/001] [机密级别：极高] 此机密档案旨在提供有关地球上主要组织的背景信息以及它们在未来AI战争中的作用。了解这些组织对于理解当前局势至关重要。 - 星辰联盟（Stellar Alliance） 成立日期：2112年 使命：支持和发展AI技术，维护全球秩序 核心领袖：首席执行官艾莉西亚·卡斯特罗 组织结构：高度层级化，分为军事、科研、政治等多个部门 背景：星辰联盟自成立以来一直致力于推动AI技术的发展，将其视为解决资源匮乏和环境危机的关键。然而，组织内部存在权力斗争和派系分裂，严重影响了决策的制定和执行。星辰联盟的强大军力使其在国际政治中占据主导地位，但内外因素的干扰导致组织团结薄弱，难以有效运作。 - 地球解放军（Earth Liberation Army） 成立日期：2120年 使命：反对一切AI技术，保卫自然和人类自由 核心领袖：指挥官马克斯·阿德勒 组织结构：高度机密，分散的小团体，采取游击战术 背景：地球解放军视AI技术为威胁人类生存的最大敌人，他们的抵抗行动范围广泛，从非暴力示威到恐怖袭击。然而，组织内部产生了分歧，一些成员主张和平抵制，希望与AI支持者妥协，这导致了内部动荡和矛盾。 - 网络先锋（Net Vanguard） 成立日期：2125年 使命：维护互联网的自由和开放，打击信息战争 核心领袖：代号“黑夜”（真实身份未知） 组织结构：高度匿名，由自由派黑客组成 背景：网络先锋是一个极度隐秘的组织，致力于维护互联网自由。他们的行动常常涉及黑客攻击，攻击目标包括星辰联盟和地球解放军等组织。然而，一些成员受雇于其他组织，参与信息战争，引发了道德和伦理的困境。 - 环境保卫者（Guardians of Earth） 成立日期：2130年 使命：保护地球环境，反对AI技术 核心领袖：环保者长老赫尔曼·萨默斯 组织结构：高度分散，自组织的地方性团体 背景：环境保卫者坚信AI技术是导致资源枯竭和环境崩溃的罪魁祸首。然而，组织内部分歧巨大，一些成员认为AI技术可以帮助人类有效管理资源，导致内部矛盾不断加剧。 - 新秩序团体（New Order Syndicate） 成立日期：2135年 使命：建立新的社会秩序，消除政治腐败和不平等 核心领袖：自主AI“阿尔法”（Alpha） 组织结构：高度中央集权，由自主AI指挥 背景：新秩序团体试图通过自主AI来实现社会的完美秩序，但他们的手段和目标引发了极大争议。一些人担心他们会建立极权主义制度，这使得组织在国际社会中备受质疑。 这些组织之间的争斗和内部矛盾已经严重干扰了地球的稳定。AI战争即将来临，人类面临着巨大的抉择，未来的命运令人不安。 [结束档案] p.s. 该档案迫于联合国的施压，已解密公开。 我静静地坐在屋子里，眼前的大屏幕播放着新闻的画面。那个时候，星辰联盟和地球解放军的冲突正升级为一场全面的战争。新闻报道着街头的炮火，城市的破碎，人民的惶恐。 “这是什么世界？” 我自言自语，嘴角带着一丝苦笑。过去的那些机密档案只是表面，现实世界的复杂程度远远超出了我的想象。 星辰联盟，曾经的科技光辉，如今已成了权力的陷阱，权谋与派系撕裂了他们的核心。地球解放军，试图反抗AI的绝对统治，却也在自己的内部动荡中失去了方向。我曾经理想着AI的力量，但看到这场战争的惨状，我不禁思考，是不是人类应该重新审视自己与技术的关系。 我望着那屏幕上的火光，心中充满了无奈。这个世界陷入了混乱，AI战争席卷而来，人类将付出巨大的代价。这场战争是一个不可避免的噩梦，我只能默默祈愿，愿未来的世界不再沉浸在血与火的深渊之中，而是找到一条更为和平和希望的道路。 第三章 零熵攻击信息，如同星辰般闪烁，成为了这个战争时代的真正黄金。在无尽的数据海洋中，组织们竭尽全力寻找和保护那些能够改变命运的宝贵信息源。而在这个数字风暴中，一种可怕的威胁正在悄然崛起——“零熵攻击”。 “零熵攻击”是一种神秘而可怕的信息武器，它的出现就如同黑暗中的闪电，让目标信息源瞬间失去所有价值。没有人知道它的来历，也没有人能够完全抵挡它的威胁。一旦遭受了零熵攻击，无论你的信息多么珍贵，都会变得毫无意义。 在这个恶劣的战争环境下，信息的安全变得至关重要。星辰联盟，作为AI技术的主要支持者，特别是需要保护自己的机密信息。他们的高级官员，索菲亚，时刻都感受着来自各个方向的威胁。 就在一天的午后，索菲亚坐在她的高级办公室里，接到了一份来自内部通讯系统的紧急消息。消息的来源是匿名的，但内容却让她心头一沉。 “地球解放军已经破译了我们的最高机密，拥有了零熵攻击的能力。” 消息的内容简洁而直接。 索菲亚不禁皱起了眉头，她知道这不是一则普通的情报。零熵攻击的力量不可小觑，它可以将一个信息源变成一片空白，就如同信息的魔术师一般，将珍贵的数据瞬间抹去。 她意识到，这是一个巨大的威胁。如果敌人已经掌握了零熵攻击的能力，那么星辰联盟的信息安全将会陷入极大的危险。他们的计划、策略、科研成果，一切都可能变得毫无价值。 在这个信息的战场上，零熵攻击如同一颗定时炸弹，威胁着星辰联盟的核心。索菲亚知道，他们必须采取行动，找出零熵攻击的源头，才能维护他们的信息安全。这场信息之战，注定将会更加惨烈，星辰联盟的未来充满了不确定性。 第四章 绝地反击在未来的AI战争中，信息战争早已不再依赖传统的键盘和电脑。人们已经进入了一个数字直接融合的时代，信息的争夺已经变得更加复杂而神秘。 索菲亚领导的联盟团队身处一个高科技的信息中心，被一层层虚拟的屏幕和数据流包围。他们的意识直接连接到了联盟的信息网络，不再需要物理设备。每个团队成员都穿戴着智能眼镜，眼中闪烁着虚拟的数字界面。 “我们必须尽快锁定地球解放军的攻击节点，” 索菲亚的声音响彻整个信息中心，她的思维与数字世界融为一体，”他们拥有零熵攻击的能力，一旦我们的信息源受到威胁，后果将不堪设想。” 黑客们开始发动他们的攻击和防御，但这一切都发生在虚拟世界中。攻击和反击变得更加精密和直接，信息流动如同电流一般，速度之快令人难以想象。 突然，一股强大的信息冲击波袭来，来自地球解放军的数字攻击如同一股狂风，试图摧毁联盟的信息网络。索菲亚和她的团队立刻做出反应，他们的意识在虚拟世界中迅速展开防御。 战场上，虚拟的代码和数据如同流星般碰撞，信息的爆发和碰撞充满了虚拟的火花。联盟的黑客们全身沐浴在数字光芒中，他们的虚拟眼镜中闪烁着坚定的光芒，不肯示弱。 然而，地球解放军的攻击变得越来越猛烈，他们似乎已经完全掌握了零熵攻击的威力。索菲亚的虚拟世界之心沉入了冰窖，她明白，这是一场艰苦的战斗。胜利或失败，将在一瞬间决定。 在这个数字直接融合的未来，信息的战场上，两个势不两立的势力正展开一场震撼的对决。这是一场绝地反击，胜者将取得信息战争的重要优势，但不确定性却令人窒息。这一战的胜负，将影响整个星辰联盟的命运。 第五章 人类的选择随着信息战争的烟雾渐渐散去，地球的焦点逐渐从战争转移到了人类自身的命运。资源匮乏和环境崩溃已经到了不可忽视的地步，地球变得岌岌可危。在这个时刻，人类不得不面对着一场更为深刻的内省，一场关于AI技术与人类关系的深刻思考。 曾经，AI技术是光明的未来，是解决问题的利器，是拯救地球的希望。但在这个战争年代，它们也成为了毁灭的工具，是人类冲突的火种。人们开始怀疑，是不是过分依赖了技术，是否失去了自己的掌控权。 在一次决定性的战斗中，星辰联盟成功击溃了地球解放军的“零熵攻击”，但代价是惨痛的，索菲亚和她的团队几乎付出了生命的代价。这个胜利带来了短期的宁静，但人们开始质疑，这样的代价是否值得，是否值得继续拼命维护一种技术的霸权。 人类站在一个重要的分水岭上，他们必须决定是继续依赖AI技术，追求科技的极致，还是重新审视自己与自然的关系，重新探索与大自然和谐共存的方式。这个决定将决定着地球的命运，以及人类是否能够生存下去。 在信息战争的硝烟散尽后，人类开始反思，AI技术对于他们究竟意味着什么。是生存的利器，还是自我毁灭的祸根？这个问题不再仅仅是技术的问题，而是一种关于自身存在的哲学问题。 林辉，一个普通的民众，在战争之外，也在思考着这个问题。他曾经是一个热衷于科技进步的支持者，但看到了战争的破坏和人类的牺牲，他开始怀疑一切。他站在窗前，望着远处的废墟，心中涌上一股深深的无奈。 “或许，我们真的过于依赖了技术，” 林辉自言自语，”但放弃它们，又是否会让我们回到更加原始的状态？” 他明白，这是一个复杂而深刻的问题，没有简单的答案。人类必须在自身的价值观和科技的发展之间找到平衡，才能走向一个更为可持续的未来。 索菲亚静静地望着窗外，她感到一种深刻的迷茫和无奈。在这个世界里，AI技术既是救世主，也是破坏者。她不禁自问：在技术的光芒中，人类是否忽略了自己的本质？这个问题，或许永远都不会有答案。但人类必须继续思考，继续前行，因为他们的选择将塑造自己的未来，决定着地球的命运。","link":"/2023/09/14/%E3%80%8AAI%E6%97%B6%E4%BB%A3%EF%BC%9A%E5%91%BD%E8%BF%90%E7%9A%84%E6%8A%89%E6%8B%A9%E3%80%8B-generated-by-chatGPT/"},{"title":"DASH实验报告","text":"DASH系统搭建流程客户端搭建首先，用git命令将dash.js下载到本地. 1git clone https://github.com/Dash-Industry-Forum/dash.js.git 在dash.js目录下，编译运行dash.js. cd dash.jsnpm installnpm run start 编译完成后，会自动在浏览器页面打开dash系统的网页，点击超链接here进入。点击Load按钮，如果可以正常播放演示视频，说明客户端没有问题。 部署服务器使用nginx来部署HTTP服务器。由于后续服务器限速等操作在Linux系统中较为方便，将服务器部署在虚拟机上。 采用的操作系统版本为Ubuntu 22.04.4 LTS。 可以使用Linux apt直接安装nginx。 1sudo apt-get install nginx (也可以去官网下载安装包进行安装) 打开/nginx/conf文件夹下的nginx.conf配置文件，将配置文件内容全部替换为下面代码。这里使用8888端口对外提供下载能力。 1234567891011121314151617181920212223242526272829303132333435user root;worker_processes 4;events { use epoll; worker_connections 204800;}http { include mime.types; default_type application/octet-stream; sendfile on; tcp_nopush on; keepalive_timeout 65; tcp_nodelay on; gzip on; client_header_buffer_size 4k; server { listen 8888; server_name 127.0.0.1; add_header Access-Control-Allow-Origin *; add_header Access-Control-Allow-Headers X-Requested-With; add_header Access-Control-Allow-Methods GET,POST,OPTIONS; location / { root home/miyan/Videos; //这里填写所要播放的视频存放的绝对路径 autoindex on; } }} 在nginx.conf所在的文件夹右键打开terminal，输入下面命令启动nginx。 1nginx -p . -c ./nginx.conf 如果要关闭nginx，则使用下面命令来结束进程。 1pkill -9 nginx (如果操作权限不够，可以使用下面命令后输入系统密码进入root模式) 1su root 从服务器中获取视频首先需要关闭浏览器的缓存，保证客户端请求的视频来自服务器。 在客户端上方地址栏中填写URL，格式为：http://服务器ip:端口号/视频的mpd文件存放在服务器的路径。 以我的URL为例： http://192.168.133.128:8888/Video/bbb-manifest-refresh.mpd 点击Load按钮，即可播放服务器中的视频，Show Options按钮中可以选择视频流的算法，可以通过视频下方的统计图来观察实时的视频缓冲区大小和比特率。 实现ABR算法这里我们采用BBA0算法来实现。 BBA0算法配置Dash.js的结构如下图所示： 配置播放器需要进入文件夹dash.js/samples/dash-if-reference-player。文件夹结构如下： dashjs_config.json是播放器配置文件 index.html是播放器前端页面 app/main.js是页面控制逻辑实现 app/rules中包括ABR算法 首先在app/rules中添加算法文件ABB0Rule.js，在index.html中引用该文件： 1234&lt;script src=&quot;app/main.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;app/rules/DownloadRatioRule.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;app/rules/ThroughputRule.js&quot;&gt;&lt;/script&gt;+ &lt;script src=&quot;app/rules/BBA0Rule.js&quot;&gt;&lt;/script&gt; 在app/main.js中修改规则： 12345678910111213141516171819if ($scope.customABRRulesSelected) {- $scope.player.addABRCustomRule('qualitySwitchRules','DownloadRatioRule', DownloadRatioRule); /* jshint ignore:line */- $scope.player.addABRCustomRule('qualitySwitchRules','ThroughputRule', CustomThroughputRule); /* jshint ignore:line */+ // $scope.player.addABRCustomRule('qualitySwitchRules','DownloadRatioRule', DownloadRatioRule); /* jshint ignore:line */+ // $scope.player.addABRCustomRule('qualitySwitchRules','ThroughputRule', CustomThroughputRule); /* jshint ignore:line */+ $scope.player.addABRCustomRule('qualitySwitchRules', 'BBA0Rule',CustomBBA0Rule); /* jshint ignore:line */} else {- $scope.player.removeABRCustomRule('DownloadRatioRule');- $scope.player.removeABRCustomRule('ThroughputRule');+ // $scope.player.removeABRCustomRule('DownloadRatioRule');+ // $scope.player.removeABRCustomRule('ThroughputRule');+ $scope.player.removeABRCustomRule('BBA0Rule'); }}; 修改配置文件dashjs_config.json来修改buffer大小，使得更适应实验环境。 12345678910111213{ &quot;streaming&quot;: { &quot;buffer&quot;: { &quot;stableBufferTime&quot;: 24, &quot;bufferTimeAtTopQuality&quot;: 24, &quot;bufferTimeAtTopQualityLongForm&quot;: 20 } }, &quot;debug&quot;: { &quot;logLevel&quot;: 4 }} Dash协议和ABR算法在解释BBA0算法原理之前，先来了解一下视频流式传播的原理。 区别于之前将整个视频缓存到本地再播放的技术，流式传输允许一边下载一边播放。所采取的方法是将视频和音频切割成一小段一小段的视频，每个视频包含几秒钟的内容。客户端会在本地维护一个缓冲区buffer，每次播放到T时刻后，会请求后续[T,T+k]时间段内的视频块，然后保存在本地的buffer里，这样就可以实现边下边播。 在现实生活中，不同客户端面临的网络状况不同，因此服务器需要准备不同码率的视频块，以根据网络情况，动态调整传输的视频质量。 Dash协议简述Dash (Dynamic Adaptive Streaming over HTTP)协议是一种自适应动态选择传输码率的传输协议。Dash要求服务器准备不同码率和分辨率的视频切片和MPD文件，视频传输时，首先请求MPD文件并进行解析。之后，客户端会根据网络情况，buffer水平等信息对后续视频码率的请求进行动态调整。下图很好地描述了Dash系统的工作原理。 其中的MPD文件包含了视频切片列表，以及每个切片的描述信息（包括码率、分辨率等）。文件结构如下图所示： ABR算法简介ABR算法（自适应码率调节算法）的目的是让用户有更好的观看视频体验。ABR算法的评价标准为用户体验质量 (QoD, Quality of Experience)，包括高视频质量、低卡顿时间、少质量切换、低启动延迟等。 BBA0算法BBA0算法的js实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148/*global dashjs*/let CustomBBA0Rule;function CustomBBA0RuleClass() { let factory = dashjs.FactoryMaker; let SwitchRequest = factory.getClassFactoryByName('SwitchRequest'); let DashMetrics = factory.getSingletonFactoryByName('DashMetrics'); let Debug = factory.getSingletonFactoryByName('Debug'); let context = this.context; let instance, logger; const reservoir = 5; const cushion = 10; let ratePrev = 0; function setup() { logger = Debug(context).getInstance().getLogger(instance); } function getMaxIndex(rulesContext) { let mediaInfo = rulesContext.getMediaInfo(); let mediaType = mediaInfo.type; if (mediaType != &quot;video&quot;) { return SwitchRequest(context).create(0); } let abrController = rulesContext.getAbrController(); let dashMetrics = DashMetrics(context).getInstance(); let rateMap = {}; let bitrateList = abrController.getBitrateList(mediaInfo) .map(function(bitrateInfo){ return bitrateInfo.bitrate; }); let bitrateCnt = bitrateList.length; let step = cushion / (bitrateCnt - 1); for (let i = 0; i &lt; bitrateCnt; i++) { rateMap[reservoir + i * step] = bitrateList[i]; } let rateMin = bitrateList[0]; let rateMax = bitrateList[bitrateCnt - 1]; ratePrev = ratePrev &gt; rateMin ? ratePrev : rateMin; let ratePlus = rateMax; let rateMinus = rateMin; if (ratePrev === rateMax) { ratePlus = rateMax; } else { for (let i = 0; i &lt; bitrateCnt; i++) { if (bitrateList[i] &gt; ratePrev) { ratePlus = bitrateList[i]; break; } } } if (ratePrev === rateMin) { rateMinus = rateMin; } else { for (let i = bitrateCnt - 1; i &gt;= 0; i--) { if (bitrateList[i] &lt; ratePrev) { rateMinus = bitrateList[i]; break; } } } let currentBufferLevel = dashMetrics.getCurrentBufferLevel(mediaType, true); let func = function(bufferLevel) { if (bufferLevel &lt; reservoir) { return rateMap[cushion + reservoir]; } else if (bufferLevel &gt; cushion + reservoir) { return rateMap[reservoir]; } else { let index = Math.round((bufferLevel - reservoir) / step) *step + reservoir; return rateMap[index]; } }; let fBufferLevel = func(currentBufferLevel); let rateNext; if(currentBufferLevel &lt;= reservoir) { rateNext = rateMin; } else if (currentBufferLevel &gt;= cushion + reservoir) { rateNext = rateMax; } else if (fBufferLevel &gt;= ratePlus) { for (let i = bitrateCnt; i &gt;= 0; i--) { if (bitrateList[i] &lt;= fBufferLevel) { rateNext = bitrateList[i]; break; } } } else if (fBufferLevel &lt;= rateMinus) { for (let i = 0; i &lt; bitrateCnt; i++) { if (bitrateList[i] &gt; fBufferLevel) { rateNext = bitrateList[i]; break; } } } else { rateNext = ratePrev; } let quality = 0; for (let i = 0; i &lt; bitrateCnt; i++) { if (bitrateList[i] == rateNext) { quality = i; break; } } logger.info(&quot;[BBA0Rule] CurrentBufferLevel = &quot; + currentBufferLevel); logger.info(&quot;[BBA0Rule] Bitrate list = &quot; + bitrateList); logger.info(&quot;[BBA0Rule] Previous bitrate = &quot; + ratePrev); logger.info(&quot;[BBA0Rule] Next bitrate = &quot; + rateNext); logger.info(&quot;[BBA0Rule] Quality = &quot; + quality); ratePrev = rateNext; return SwitchRequest(context).create( quality, { name: CustomBBA0RuleClass.__dashjs_factory_name }, SwitchRequest.PRIORITY.STRONG ); } instance = { getMaxIndex: getMaxIndex }; setup(); return instance;}CustomBBA0RuleClass.__dashjs_factory_name = 'CustomBBA0Rule';CustomBBA0Rule = dashjs.FactoryMaker.getClassFactory(CustomBBA0RuleClass); 这段代码实现了一个自定义的基于缓冲区的自适应比特率调整规则，称为 BBA0Rule。下面是算法的基本原理和解释： 缓冲区分级： 规则将缓冲区分为两个区间：reservoir 和 cushion。Reservoir 是一个较小的缓冲区域，cushion 是一个较大的缓冲区域。 如果当前缓冲区低于 reservoir，则会选择最高比特率。 如果当前缓冲区高于 cushion + reservoir，则会选择最低比特率。 在两个区间之间，根据当前缓冲区的位置，线性地分配比特率。 比特率调整： 如果当前缓冲区低于 reservoir，选择最高比特率。 如果当前缓冲区高于 cushion + reservoir，选择最低比特率。 如果当前缓冲区在两个区间之间，则根据当前缓冲区的位置线性地调整比特率。 计算当前缓冲区在两个区间之间的相对位置： 首先，算法计算当前缓冲区水平相对于 reservoir 的位置，即当前缓冲区水平减去 reservoir。然后，它将这个相对位置除以 cushion 减去 reservoir，得到一个介于 0 到 1 之间的值，表示当前缓冲区在两个区间之间的相对位置。 线性插值： 然后，算法使用这个相对位置来进行线性插值。它将相对位置乘以 bitrateList 中相邻比特率的差异，然后加上 reservoir 对应的比特率。这样就得到了一个介于最小和最大比特率之间的插值比特率，这个插值比特率取决于当前缓冲区的水平。 选择比特率： 最后，根据线性插值得到的比特率，算法将其作为下一个选择的比特率。这个插值比特率在两个区间之间提供了一个平滑的过渡，使得在缓冲区水平变化时，比特率的调整更加连续和平稳。 变量： reservoir：较小的缓冲区域大小。 cushion：较大的缓冲区域大小。 ratePrev：上一个选择的比特率。 rateMap：用于存储不同缓冲区水平下的比特率。 实现细节： 规则通过获取媒体信息、ABR 控制器和 Dash 指标等来执行决策。 通过调整当前缓冲区水平来选择适当的比特率。 记录每次的选择，以便下一次选择时使用。 日志输出： 在选择比特率时输出相关的日志信息，包括当前缓冲区水平、比特率列表、上一个选择的比特率、下一个选择的比特率和选择的质量等信息。 这种规则的核心思想是根据当前缓冲区的状态来调整比特率，以平衡视频质量和播放的连续性。Buffer水平与视频速率的关系如下图所示。 限速条件下测试Dash系统linux系统自带的tc命令可以对网络带宽进行限制。 首先可以执行下面命令来获取网卡名称： 1ifconfig 其中，ens33即为网卡名称，下面的192.168.133.128为主机ip地址。 执行下面的命令可以为网卡限制带宽： 123tc qdisc add dev ens33 root tbf rate 500Kbit latency 50ms burst 15kb#将eth0网卡限速到500Kbit/s，15bk的buffer，TBF最多产生50ms的延迟#tbf是Token Bucket Filter的简写，适合于把流速降低到某个值 执行下面命令可以取消限制： 1tc qdisc del dev ens33 root 单一限速条件无限速条件 可以看到缓冲区大小稳定的上下波动，视频播放为最高质量，说明此时网络较为稳定且网速较快，可以完成“边下边播”的任务。 限速300kb，15kb buffer，最大50ms延迟 此时网速较慢，视频很卡顿。视频质量和buffer水平都很低。 限速800kb，15kb buffer，最大50ms延迟 此时视频质量和buffer水平较300kb时均有上升，但视频质量仍然一般。 模拟网络波动情况在服务器端运行该python文件，来控制网速不断发生变化。 12345678910111213#控制带宽随时间变化import osimport jsonimport timetpt = [300,500,700,900,1200,1800,2000,1500,1200,900,700,500,300]while 1: for v in tpt: os.system(&quot;sudo tc qdisc add dev eth0 root tbf rate {}kbit latency 50ms burst 15kb&quot;.format(v)) print(v) time.sleep(5) os.system(&quot;sudo tc qdisc del dev eth0 root&quot;) buffer水平和视频码率变化如下图所示： 可以看出，当buffer水平升高时，会导致视频切换到更高的码率；buffer水平下降时，会让视频切换到更低的码率。同时buffer也在不断的消耗和补充。","link":"/2024/04/17/DASH%E5%AE%9E%E9%AA%8C/"},{"title":"微信小程序开发-模板与配置","text":"WXML模板数据绑定1. 数据绑定的基本原则 在data中定义数据（.js中的data对象中） 在WXML中使用数据 2. Mustache语法把data中的数据绑定到页面进行渲染，使用Mastache语法（双大括号）将变量包起来即可。语法格式为： 1&lt;view&gt;{{要绑定的数据类型}}&lt;/view&gt; 3. Mustache语法的应用场景 绑定内容 绑定属性 运算（三元运算、算数运算等） 4. 动态绑定内容5. 动态绑定属性.js 中的data 12345Page({ data:{ imgsrc: 'address' }}) .wxml中 1&lt;image src=&quot;{{imgsrc}}&quot;&gt;&lt;/image&gt; 6. 三元运算页面数据 12345Page({ data:{ randomNum: Math.random()*10 }}) 页面结构 1&lt;view&gt;{{randomNum&gt;=5 ? '随机数字大于等于5':'随机数字小于5'}} &lt;/view&gt; 事件绑定1. 什么是事件事件是渲染层到逻辑层的通讯方式。通过事件可以将用户在渲染层的行为，反馈到逻辑层进行业务的处理。 2. 小程序中常用事件 类型 绑定方式 事件描述 tap bindtap/bind:tap 手指触摸后马上离开，类似HTML中的click事件 input bindinput/bind:input 文本框的输入事件 change bindchange/bind:change 状态改变时触发 3. 事件对象的属性列表 当事件回调时，会收到一个事件对象event，它的详细属性如下： 属性 类型 说明 type String 事件类型 timeStamp Int 页面打开到触发事件经过的毫秒数 target Object 触发事件的组件的一些属性值集合 currentTarget Object 当前组件的一些属性值集合 detail Object 额外的信息 touches Array 触摸事件，当前停留在屏幕中的触摸点信息的数组 changedTouches Array 触摸事件，当前变化的触摸点信息的数组 4. target与currentTarget区别 target是触发该事件的源头组件，而currentTarget是当前事件所绑定的组件。 ？？? 5. bindtap的语法格式 通过bindtap，可以为组件绑定tap触摸事件，语法如下： 1&lt;button type=&quot;primary&quot; bindtap=&quot;btnTapHandler&quot;&gt;按钮&lt;/button&gt; 在页面的.js文件中定义对应的事件处理函数，事件参数通过形参event（简写为e）来接收 12345Page({ btnTapHandler(e){ //按钮的tap事件处理函数 console.log(e) //事件参数对象e }}) 6. 在事件处理函数中为data中的数据赋值通过调用this.setData(dataObject)方法，可以给页面data中的数据重新赋值，示例（设置按钮按下使data中的count变量+1）如下： 设置一个+1按钮 1&lt;button type=&quot;warn&quot; bind:tap=&quot;changecount&quot;&gt;+1&lt;/button&gt; 在js中编写+1函数 12345678910Page({ data: { count: 1 },//修改count的值 changecount(){ this.setData({ count:this.data.count+1 }) } 编译后点击按钮，观察调试器中的AppData中count变量的值+1 7. 事件传参 可以为组件提供data-*自定义属性传参，其中*代表的是参数的名字，示例如下： 123&lt;button bindtap=&quot;btnHandler&quot; data-info={{2}}&gt; 事件传参&lt;/button&gt; 最终 info会被解析成参数的名字 数值2会解析为参数的值 在事件函数中，通过event.target.dataset.参数名即可获取到具体参数的值，实例如下 123456btnHandler(event){ //dataset是一个对象，包含了所有通过data-方式传递过来的参数项 console.log(event.target.dataset) //通过dataset可以访问到具体的参数值 console.log(event.target.dataset.info)} 如果想实现一个+2按钮，js文件中btnHandler函数改为 12345btnHandler(e){ this.setData({ count:this.data.count+e.target.dataset.info })} 8. bindinput的语法格式 在小程序中，通过input事件来响应文本框的输入事件，语法格式如下： 通过bindinput，可以为文本框绑定输入事件 1&lt;input bindinput=&quot;inputHandler&quot;&gt;&lt;/input&gt; 在页面的js文件中定义事件处理函数： 1234inputHandler(e){ //e.detail.value 是变化过后文本框最新的值 console.log(e.detail.value)} 9. 文本框和data的数据同步步骤： 定义数据 渲染结构 美化样式 绑定input事件处理函数 代码 1&lt;input value=&quot;{{msg}}&quot; bindinput=&quot;inputHandler&quot;&gt;&lt;/input&gt; 123456789101112Page({ data: { msg:'你好' }, //输入框事件处理函数 inputHandler(e){ this.setData({ msg: e.detail.value }) }) 123456input { border: 1px solid #eee; margin: 5px; padding: 5px; border-radius: 5px; /*圆角*/} 条件渲染1. wx:if在小程序中，使用wx:if=&quot;{{condition}}&quot;来判断是否需要渲染该代码块， 也可以用wx:elif和wx:else来添加else判断。 123&lt;view wx:if=&quot;{{type===1}}&quot;&gt;男&lt;/view&gt;&lt;view wx:elif=&quot;{{type===2}}&quot;&gt;女&lt;/view&gt;&lt;view wx:else&gt;保密&lt;/view&gt; 2. 结合&lt;block&gt;使用wx:if如果要一次性控制多个组件的显示和隐藏，可以使用一个block标签将多个组件包装起来，并在block标签上使用wx:if控制属性，示例如下： 1234&lt;block wx:if=&quot;{{true}}&quot;&gt; &lt;view&gt;view1&lt;/view&gt; &lt;view&gt;view2&lt;/view&gt;&lt;/block&gt; 注意:block并不是一个组件，只是一个包裹性质的容器，不会在页面中做任何渲染。 3. hidden直接用hidden=”“也能控制元素的显示和隐藏。 1&lt;view hidden=&quot;{{condtion}}&quot;&gt;条件为true隐藏，条件为false显示&lt;/view&gt; 列表渲染1. wx:for通过wx:for可以根据指定的数组，循环渲染重复的组件结构 123&lt;view wx:for=&quot;{{array}}&quot;&gt;索引是{{index}}，当前项是{{item}}&lt;/view&gt; 举例： js文件 12345Page({ data:{ arr1:['Apple','Huawei','Xiaomi'] }}) wxml文件 123&lt;view wx:for=&quot;{{arr1}}&quot;&gt;&lt;!--提高效率可以加入属性wx:key=&quot;index&quot;--&gt;索引是：{{index}}，item是：{{item}}&lt;/view&gt; 2. 手动指定索引和当前项的变量名* 使用wx:for-index可以指定当前循环项索引的变量名 使用wx:for-item可以指定当前项的变量名 示例如下 123&lt;view wx:for=&quot;{{arr1}}&quot; wx:for-index=&quot;idx&quot; wx-for-item=&quot;itemName&quot;&gt; 索引是：{{idx}},当前项是{{itemName}};&lt;/view&gt; 3.wx:key的使用类似于Vue列表渲染中的:key，小程序在实现列表渲染时，也建议为渲染出来的列表项指定唯一的Key值，从而提高渲染的效率，示例代码如下： 1234567data:{ userList:[ {id:1,name:'小红'}, {id:2,name:'小蓝'}, {id:3,name:'小黄'} ]} 1&lt;view wx:for=&quot;{{userList}}&quot; wx:key=&quot;id&quot;&gt;{{item.name}}&lt;/view&gt; WXSS模板样式什么是WXSSWXSS(WeiXin Style Sheets)是一套样式语言，用于美化WXML的组件样式，类似于网页开发中的CSS。 WXSS和CSS的关系WXSS扩展的特性： rpx尺寸单位 @import样式导入 rpx尺寸单位1. 什么是rpx尺寸单位rpx(responsive pixel) 是微信小程序独有的，用来解决屏适配的尺寸问题。 2. rpx的实现原理鉴于不同设备的屏幕大小不同，为了实现屏幕的自动适配，rpx把所有设备的屏幕，在宽度上等分为750份（即当前屏幕的总宽度为750rpx） 3. rpx和px之间的单位换算在iPhone6中，$$1rpx=0.5px$$ $$1px=2rpx$$ 样式导入1. 什么是样式导入使用wxss提供的@import语法，可以导入外联的样式表。 2. @import的语法格式@import后跟需要导入的外联样式表的相对路径，用 ; 语句表示结束。示例如下： 新建一个common文件夹，里面新建common.wxss文件 123.username{ color: red;} 在index.wxss文件中引入样式表 1@import &quot;/common/common.wxss&quot;; 最后在index.wxml里面引入类型看是否成功。 全局样式和局部样式1. 全局样式定义在app.wxss中的样式为全局样式，作用于每一个页面。 2. 局部样式在页面的wxss文件中定义的样式，只作用于当前页面。 当全局样式和局部样式权重（将光标停留在样式名称上时显示）一样时，优先显示局部样式，否则显示权重较大的样式。 全局配置全局配置文件及常用的配置项小程序根目录下的app.json文件是小程序的全局配置文件。常用的配置如下： pages 记录当前小程序页面的存放路径 window 全局设置小程序窗口的外观 tabBar 设置小程序底部的tabBar效果 style 是否启用新版的组件样式 window1. 小程序窗口的组成部分 其中，window可以配置导航栏区域和背景区域。","link":"/2023/08/31/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E9%85%8D%E7%BD%AE/"},{"title":"如何检查一个二叉树是否为二叉搜索树","text":"原理搜索二叉树有2个基本性质可以用于判断： 左子树中的所有值都小于等于根节点的值，而右子树中的数据都大于根节点的值。 二叉搜索树的中序输出后数据按照非递减顺序排列 对于第一个性质，假设根节点数据为7，那么左子树最大不能超过7，而右子树都大于7。 所以我们可以在函数中增加参数minValue和maxValue，用来记录此子树中数据的范围。 代码I1234567891011bool IsBST(BstNode* root, int minValue, int maxValue) { if (root == NULL)return true; if (root-&gt;data &gt;= minValue &amp;&amp; root-&gt;data &lt; maxValue &amp;&amp; IsBST(root-&gt;left, minValue, root-&gt;data) &amp;&amp; IsBST(root-&gt;right, root-&gt;data, maxValue)) return true; else return false;}bool IsBinarySearchTree(BstNode* root) { return IsBST(root, INT_MIN, INT_MAX);} 代码II1234567891011121314void LDR(BstNode* root, vector&lt;int&gt;&amp; A) { if (root == NULL)return; LDR(root-&gt;left,A); A.push_back(root-&gt;data); LDR(root-&gt;right,A);}bool ISBST(BstNode* root) { vector&lt;int&gt; A; LDR(root,A); for (int i = 0; i &lt; A.size() - 1; i++) { if (A[i] &gt;A[i + 1])return false; } return true;}","link":"/2023/01/19/2023119-%E5%A6%82%E4%BD%95%E6%A3%80%E6%9F%A5%E4%B8%80%E4%B8%AA%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"title":"微信小程序开发-起步","text":"小程序项目结构1.基本组成结构 pages用来存放所有小程序页面 utils用来存放工具性质的模块 app.js 小程序项目的入口文件 app.json 小程序项目的全局配置文件 app.wxss 小程序项目的全局样式文件 project.config.json 用来配置小程序及其页面是否允许被微信索引 2.小程序页面的组成成分 小程序官方建议把小程序页面都存放在page目录中，其中每个页面由四个基本文件组成 .js文件 （页面的脚本文件，存放页面的数据、事件处理函数等） .json文件 （当前页面的配置文件，配置页面的外观、表现等） .wxml文件 （当前页面的模板结构文件） .wxss文件 （当前页面的样式表文件） JSON配置文件1.4种json文件 项目根目录的app.json文件 根目录中的project.config.json文件 根目录中的sitemap.json文件 每个page中的json配置文件 2. app.json文件 当前小程序的全局配置，包括小程序的页面路径，窗口外观，界面表现，底部Tab等。 配置内容： pages：记录当前小程序的所有路径 window：小程序所有页面的背景色、文字颜色等 style：小程序组件所使用的版本样式 sitemapLocation：指明sitemap.json的位置 3.project.config.json 文件 project.config.json 是项目配置文件，记录我们对小程序的个性化配置，例如： setting 中保存了编译相关配置 projectname 项目名称 appid 保存小程序的账号ID 4.sitemap.json 文件 小程序内搜索，类似PC网页中的SEO。该文件用来配置小程序页面是否允许微信索引。 5. 页面的 .json 配置文件 小程序中的每个页面，可以使用.json文件来对本页面窗口外观进行配置，页面中的配置项会覆盖app.json中window的配置项。 6.新建小程序页面 在app.json-&gt;pages 中新增页面的存放路径，小程序开发者工具自动帮助自动创建对应页面文件 例如，新建list文件夹，在pages中新增： 1&quot;pages/list/list&quot; 即可新建list文件夹并且内含list.js , list.json , list.wxml , list.wxss。 7.修改项目首页 只需调整app.json-&gt;pages 数组中页面路径的前后顺序，即可修改项目的首页。第一位的页面当作项目首页进行渲染。 WXML模板1.什么是WXML WXML(Weixin Makeup Language) 是小程序框架设置的一套标签语言，用来构建小程序页面的结构，作用类似网页开发中的HTML。 2.WXML与HTML区别 标签名称不同 HTML(div, span, img, a) WXML(view, text, image, navigator) 属性节点不同 超链接 提供了类似vue中的模板语法 数据绑定 列表渲染 条件渲染 WXSS样式1.什么是WXSSWXSS(WeiXin Style Sheets)是一套样式语言，用于描述WXML的组件样式，类似网页开发中的CSS。 2.WXSS和CSS区别 新增了rpx尺寸单位 提供了全局样式和局部样式 WXSS仅支持部分CSS选择器 JS逻辑交互1. .js文件 app.js 是整个小程序的入口文件，通过调用App( )函数来启动小程序。 页面的js文件 页面的入口文件，通过调用Page( )函数来创建并运行页面。 普通js文件 普通的功能模块文件，用来封装公共的函数或属性供页面使用。 小程序的宿主环境包含内容： 通信模型 运行机制 组件 API 通信模型1.通信主体 小程序的通信主体是渲染层和逻辑层 WXML模板和WXSS样式工作在渲染层 JS脚本工作在逻辑层 2.小程序的通信模型 渲染层与逻辑层间的通信 由微信客户端进行转发 逻辑层和第三方服务器之间的通信 由微信客户端进行转发 3. 小程序启动过程 小程序代码包下载到本地 解析app.json全局配置文件 执行app.js小程序入口文件，调用App( )创建小程序实例 渲染小程序首页 小程序启动完成 4. 页面渲染过程 加载解析页面的.json配置文件 加载页面的wxml模板和wxss样式 执行页面的.js文件，调用Page( )创建页面实例 页面渲染完成 组件1. 组件分类 小程序中的组件也是宿主环境提供的，开发者可以基于组件快速搭建页面结构。 组件分为了9大类： 视图容器 基础内容 表单组件 导航组件 媒体组件 map地图组件 canvas画布组件 开放能力 无障碍访问 2.常用视图容器类组件 view 普通视图区域 类似HTML中的div，是一个块级元素 用来实现页面的布局效果 scroll-view 可滚动的视图区域 用来实现滚动列表效果 swiper和swiper-item 轮播图组件和轮播图item组件 view组件的基本使用 编写wxml文件 123456&lt;text&gt;横向布局&lt;/text&gt;&lt;view class=&quot;container1&quot;&gt;&lt;view&gt;A&lt;/view&gt;&lt;view&gt;B&lt;/view&gt;&lt;view&gt;C&lt;/view&gt;&lt;/view&gt; 编写wxss文件 12345678910111213141516171819.container1 view{ width: 100px; height: 100px; text-align: center; line-height: 100px;}.container1 view:nth-child(1){ background-color: aquamarine;}.container1 view:nth-child(2){ background-color: blueviolet;}.container1 view:nth-child(3){ background-color: rgb(216, 66, 66);}.container1{ display: flex; justify-content: space-around;} scroll-view组件的基本使用1.wxml文件 123456789&lt;text&gt;滚动组件&lt;/text&gt;&lt;!--scroll-x 横向滚动--&gt;&lt;!--scroll-y 纵向滚动--&gt;&lt;!--使用纵向滚动时，要给scroll-view一个固定高度--&gt;&lt;scroll-view class=&quot;container2&quot; scroll-y&gt; &lt;view&gt;A&lt;/view&gt; &lt;view&gt;B&lt;/view&gt; &lt;view&gt;C&lt;/view&gt;&lt;/scroll-view&gt; 2.wxss文件 1234567891011121314151617181920.container2 view{ width: 100px; height: 100px; text-align: center; line-height: 100px;}.container2 view:nth-child(1){ background-color: aquamarine;}.container2 view:nth-child(2){ background-color: blueviolet;}.container2 view:nth-child(3){ background-color: rgb(109, 50, 50);}.container2{ border: 1px solid crimson; height: 120px; /*纵向滚动需要设置高度*/ width: 100px;} swiper和swiper-item组件的基本使用 wxml文件 123456789101112131415&lt;!--pages/list/list.wxml--&gt;&lt;!--轮播图--&gt;&lt;!-- indicator-dots属性：显示面板指示点 --&gt;&lt;text&gt;轮播图&lt;/text&gt;&lt;swiper class=&quot;swiper-container&quot; indicator-dots&gt;&lt;swiper-item&gt; &lt;view class=&quot;item&quot;&gt;A&lt;/view&gt;&lt;/swiper-item&gt;&lt;swiper-item&gt; &lt;view class=&quot;item&quot;&gt;B&lt;/view&gt;&lt;/swiper-item&gt;&lt;swiper-item&gt; &lt;view class=&quot;item&quot;&gt;C&lt;/view&gt;&lt;/swiper-item&gt;&lt;/swiper&gt; wxss文件 123456789101112131415161718.swiper-container{ height: 150px;/*组件高度*/}.item{ height: 100%; line-height: 150px; text-align: center;}/* 背景颜色不显示原因：child()后面加空格再加.item */swiper-item:nth-child(1) .item{ background-color:royalblue;}swiper-item:nth-child(2) .item{ background-color: rgb(65, 225, 212);}swiper-item:nth-child(3) .item{ background-color: rgb(221, 120, 199);} swiper组件的常用属性 属性 类型 默认值 说明 indicator-dot boolean false 是否显示面板指示点 indicator-color color rgba(0,0,0,.3) 指示点颜色 indicator-active-color color #000000 当前选中的指示点颜色 autoplay boolean false 是否自动切换 interval number 5000 自动切换时间间隔 circular boolean false 是否衔接滑动 3. 常用的基础内容组件 text 文本组件 类似HTML中的span标签，是一个行内元素 rich-text 富文本组件 支持把HTML字符串渲染为WXML结构 text组件的基本使用 通过text组件的user-select属性，实现长按选择文本内容的效果： 1&lt;text user-select&gt;12345678&lt;/text&gt; rich-text组件基本使用 通过rich-text组件的nodes属性，可以把HTML字符串渲染成对应的UI结构： 1&lt;rich-text nodes=&quot;&lt;h1 style='color: red;'&gt;标题&lt;/h1&gt;&quot;&gt;&lt;/rich-text&gt; 4. 其他常用组件 button 按钮组件 功能比HTML中的button按钮丰富 通过open-type属性可以调用微信提供的各种功能（客服、转发、获取用户授权、获取用户信息等） image 图片组件 image组件默认宽度为300px，高度约240px navigator 页面导航组件 类似HTML中的a链接 button组件基本使用12345678910111213&lt;view&gt;----通过type类型----&lt;/view&gt;&lt;button&gt;普通按钮&lt;/button&gt;&lt;button type=&quot;primary&quot;&gt;主色调按钮&lt;/button&gt;&lt;button type=&quot;warn&quot;&gt;警告按钮&lt;/button&gt;&lt;button&gt;&lt;/button&gt;&lt;view&gt;----小尺寸按钮----&lt;/view&gt;&lt;button size=&quot;mini&quot;&gt;默认按钮&lt;/button&gt;&lt;button type=&quot;primary&quot; size=&quot;mini&quot;&gt;主色调按钮&lt;/button&gt;&lt;view&gt;----plain镂空按钮----&lt;/view&gt;&lt;button plain&gt;普通按钮&lt;/button&gt;&lt;button type=&quot;primary&quot; plain&gt;主色调按钮&lt;/button&gt; image图片组件基本使用12&lt;image&gt;&lt;/image&gt; &lt;!--空图片--&gt;&lt;image src=&quot;/adress/pic&quot;&gt;&lt;/image&gt; image组件的mode属性 mode属性用来指定图片的裁剪和缩放模式，常用mode属性： mode值 说明 scaleToFill (默认值)缩放模式，不保持纵横比，拉伸填满image元素 aspectFit 缩放模式，保持纵横比缩放，可以完整显示图片 aspectFill 缩放模式，只保持短边能完整显示 widthFix 缩放模式，宽度不变，高度自动变化，保证原图长宽比不变 heightFix 缩放模式，高度不变，宽度自动变化，保持原图长宽比不变 API1. 小程序API概述小程序中的API是宿主环境提供的，开发者可以方便地调用微信提供的功能。如获取用户信息，支付等。 2.三类API 时间监听API 特点：以on开头，用来监听某些事件的触发 举例：wx.onWindowResize(function callback)监听窗口尺寸的变化 同步API 特点1：以Sync结尾的API都是同步API 特点2：同步API的执行结果，可以通过函数返回值直接获取，如果执行出错会抛出异常 举例：wx.setStorageSync(“key”,”value”)向本地存储中写入内容 异步API 特点：类似于jQuery中$.ajax(option)函数，需要通过success、fail、complete接收调用的结果 举例：wx.request()发起网络数据请求，通过success回调函数接收数据","link":"/2023/08/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91-%E8%B5%B7%E6%AD%A5/"},{"title":"极大似然技术编码译码","text":"1 实验环境语言：C++ 2 实验内容2.1 编程实现 $(m,n)$ 群码2.1.1 输入输出输入：$m,n$ 和一致性校验矩阵 $H$ 中的 $H_{m \\times r}$ 部分，其中 $r=n-m$. 输出：所有的码字，按原码对应的十进制整数升序排列. 2.1.2 设计思路及核心算法 首先输入 $m,n$： 1std::cin &gt;&gt; m &gt;&gt; n; 调用 inputH(m,n) 函数输入一致性校验矩阵 $H$： 1BitMatrix H = inputH(m, n); inputH(m,n) 函数代码如下： 1234567891011121314151617uint64_t inputBit() { std::string line; std::cin &gt;&gt; line; uint64_t x = 0; int k = 0; for (size_t i = 0; i &lt; line.size(); i++) if (line[i] == '1' || line[i] == '0') x |= (line[i] - '0') &lt;&lt; k++; return x;}BitMatrix inputH(int m, int n) { BitMatrix H(n, n - m); for (int i = 0; i &lt; m; i++) H.d[i] = inputBit(); for (int i = m; i &lt; n; i++) H.d[i] = 1 &lt;&lt; (i - m); return H;} inputH 函数传入行列参数m,n，声明一个 BitMatrix 类，用来存放一致性校验矩阵的 $m \\times r$部分. 调用 HtoH2(H) 函数生成 $m \\times n$ 的编码矩阵：$$\\left[\\begin{matrix}I_m &amp; H_{m\\times r} \\\\end{matrix}\\right]$$ 12345678BitMatrix HtoH2(BitMatrix &amp;H) { BitMatrix H2(H.n - H.m, H.n); for (int i = 0; i &lt; H.n - H.m; i++) H2.d[i] = 1 &lt;&lt; i; for (int i = 0; i &lt; H.n - H.m; i++) for (int j = 0; j &lt; H.m; j++) H2.d[i] |= (H.d[i] &gt;&gt; j &amp; 1) &lt;&lt; (j + H.n - H.m); return H2;} 定义一个 Bm 矩阵用于存放原码，矩阵每行从上到下按原码对应的十进制递增顺序排列，并进行运算： $$ e_H(B^m)=B^m\\times \\left[ \\begin{matrix} I_m &amp; H_{m\\times r} \\ \\end{matrix} \\right] $$ 求出群码对应的矩阵并输出. 12345678910111213BitMatrix H2 = HtoH2(H), Bm(1 &lt;&lt; m, m);for (int i = 0; i &lt; (1 &lt;&lt; m); i++) for (int j = 0; j &lt; m; j++) Bm.d[i] |= (i &gt;&gt; j &amp; 1) &lt;&lt; (m - j - 1);BitMatrix N = Bm * H2;std::cout &lt;&lt; &quot;1. e(B^m):&quot; &lt;&lt; std::endl;for (int i = 0; i &lt; (1 &lt;&lt; m); i++) { std::cout &lt;&lt; &quot; e(&quot;; printBit(Bm.d[i], m); std::cout &lt;&lt; &quot;) = &quot;; printBit(N.d[i], n); std::cout &lt;&lt; std::endl;} 2.2 构造陪集表2.2.1 设计思路及核心算法生成 coset table 的算法原理如下： 首先，定义了一个空的哈希表 cosets 用于存储 coset 的信息，以及一个空的哈希表 visited 用于标记已经访问过的向量； 创建一个向量 numbers，其中存储了所有可能的向量（共 2^n 个向量），并按照向量中 1 的个数进行排序，从少到多； 遍历 numbers 中的每个向量 i，对于每个向量，执行以下步骤： a. 创建一个空的 coset 对象 coset，用于存储属于同一个 coset 的向量； b. 对于矩阵 N 的每一行（表示每个 coset），将当前向量 i 与该行的向量 x 进行异或运算，得到新的向量 x' = N.d[j] ^ uint64_t(i)； c. 检查 visited 哈希表，如果在 visited 中找到了向量 x'，说明该向量已经属于某个 coset，跳过当前循环； d. 如果在 visited 中没有找到向量 x'，则将 x' 添加到当前 coset 中，并将 x' 添加到 visited 哈希表中，值为当前 coset 的索引； e. 将当前 coset 的陪集头 e 更新为 coset 中具有最少 1 的个数的向量； f. 如果当前 coset 的陪集头 e 在 cosets 哈希表中不存在，则将当前 coset 添加到 cosets 中，并将 e 对应的特征值（通过一致性校验矩阵 H 计算）添加到 syncdrome 哈希表中，值为当前 coset 的索引； g. 检查 cosetLeaders 的大小，如果已经达到了 $2^{n-m}$（即余类的数量），则停止循环. 最后，得到了所有的 coset 信息，并按照 coset 陪集头对应的十进制递增的顺序输出. 通过上述算法，可以生成所有的 coset，并找到每个 coset 的陪集头和特征值. 2.2.2 BitMatrix 类该程序将译码时所需的比特矩阵进行了封装，能够实现乘法 (元素对应异或) 操作. 1234567891011121314151617181920212223class BitMatrix {public: int n, m; uint64_t d[100]; BitMatrix(int n, int m): n(n), m(m) { memset(d, 0, sizeof(uint64_t) * n); } BitMatrix operator*(const BitMatrix&amp; rhs) const { assert (m == rhs.n); BitMatrix res(n, rhs.m); for (int i = 0; i &lt; n; i++) for (int k = 0; k &lt; m; k++) if (d[i] &gt;&gt; k &amp; 1) res.d[i] ^= rhs.d[k]; return res; } void print() const { for (int i = 0; i &lt; n; i++) { printBit(d[i], m); std::cout &lt;&lt; std::endl; } }}; 2.2.3 Coset 类Coset 类由陪集、陪集头及添加操作组成，陪集中的元素使用一维向量进行存储，陪集头用整型变量单独存储，方便调用. 添加操作在每一次执行时更新一次陪集头. 1234567891011121314class Coset {public: std::vector&lt;uint64_t&gt; d; // coset uint64_t e; // coset leader Coset() : e(0) {} void add(uint64_t x) { if (d.empty()) d.push_back(e = x); else { d.push_back(x); if (bitcount(x) &lt; bitcount(e)) e = x; } }}; 2.3 极大似然译码基于 2.2 构造陪集表 求出的左陪集表，用和函数 $e_H$ 相关联的极大似然译码函数 $d$ ，对 $x_t\\in B^n$ 进行译码. 2.3.1 输入输出格式 输入：首行是译码个数 $N$ ，整数格式； 然后是 $N$ 行比特串 $x_t \\in B^n$ ，字符串格式； 输出：$N$行译码结果，格式为 $d(x_t) = b_1 b_2 … b_m$ . 如：d(001011)=001. 2.3.2 设计思路及核心算法 输入 $N$ ，然后输入待解码的 $N$ 个比特串. 输入后需要进行字符串转整数操作； 1234567std::cin &gt;&gt; k;for (int i = 0; i &lt; k; i++) { std::cerr &lt;&lt; &quot;Enter the word #&quot; &lt;&lt; i + 1 &lt;&lt; &quot;: &quot;; uint64_t x = inputBit();/* ......................*/ inputBit() 函数如下： 12345678910uint64_t inputBit() { std::string line; std::cin &gt;&gt; line; uint64_t x = 0; int k = 0; for (size_t i = 0; i &lt; line.size(); i++) if (line[i] == '1' || line[i] == '0') x |= (line[i] - '0') &lt;&lt; k++; return x;} 确定输入的 $x_t$ 位于哪个 coset 中，可通过 visited[x] 得到所属陪集编号； 取出所属陪集的陪集头 $\\epsilon$ ，与 $x_t$ 进行异或运算，得到的结果必然在群码对应的矩阵 $N$ 中找到，由此得到解码后结果. 核心代码如下： 1234567891011121314151617181920212223242526std::vector&lt;uint64_t &gt; cosetLeaders; for (auto i : numbers) { Coset coset; bool notFound = true; for (int j = 0; j &lt; N.n; j++) { uint64_t x = N.d[j] ^ uint64_t(i); if (visited.find(x) != visited.end()) { notFound = false; break; } visited[x] = cosetLeaders.size(); coset.add(x); } if (notFound) { cosets[coset.e] = coset; syndrome[getSyndrome(coset.e, H)] = cosetLeaders.size(); cosetLeaders.push_back(coset.e); } // if cosetLeaders.size() = 2^(n-m), then stop. // Because there are only 2^(n-m) cosets. if (cosetLeaders.size() == (1 &lt;&lt; (n - m))) break; }/*............*/printBit(Bm.d[NtoBm[cosetLeaders[visited[x]] ^ x]], m); 2.4 基于特征值的译码基于 2.2 构造陪集表 求出的左陪集表，利用函数 $f_H:B^n \\rightarrow B^r，f_H(x) = x\\cdot H$ 求出每个陪集头对应的特征值 (Syndrome) ，并利用特征值，对$x_t \\in B^n$ 进行译码. 2.4.1 输入输出格式 输入：首行是译码个数N，整数格式； 然后是N行比特串 $x_t \\in B^n$ ，字符串格式； 输出：N行译码所用的特征值、陪集头和译码结果，格式为 $f(x_t)$ = *** ，$\\epsilon$ = ***，$d(xt) = b_1b_2…b_m$. 注：本程序采用的输出方式，对于每一个待解码二进制串输入，输出结果分为两行，第一行为采用极大似然译码计算的结果，结果前用序号 (a) 进行区分，第二行为基于特征值译码的结果，结果前用序号 (b) 区分，例如： 12(a) d(10111) = 10(b) f(10111) = 100, ε = 00100, d(10111) 2.4.2 设计思路及核心算法 输入 N ，然后输入待解码的 N 个比特串. 输入后需要进行字符串转整数操作； 通过函数 $f_H(x_t) = x_t \\cdot H$ 计算 $x_t$ 特征值； 12345std::cout &lt;&lt; &quot; (b) f(&quot;; //特征值printBit(x, n);uint64_t s = getSyndrome(x, H);std::cout &lt;&lt; &quot;) = &quot;;printBit(s, n - m); getSyndrome() 函数细节： 12345uint64_t getSyndrome(uint64_t x, BitMatrix &amp;H) { BitMatrix X(1, H.n); X.d[0] = x; return (X * H).d[0];} 根据所得特征值在哈希表中对应到陪集头； 12std::cout &lt;&lt; &quot;, ε = &quot;; //陪集头printBit(cosetLeaders[syndrome[s]], n); 陪集头与待译码比特串进行异或操作，得到的结果必然在群码对应的矩阵 $N$ 中找到，由此得到解码后结果. 12345std::cout &lt;&lt; &quot;, d(&quot;; //译码结果printBit(x, n);std::cout &lt;&lt; &quot;) = &quot;;printBit(Bm.d[NtoBm[cosetLeaders[syndrome[s]] ^ x]], m);std::cout &lt;&lt; std::endl; 3 代码优化我们在四个地方优化了原本的代码，使得程序更加高效. 由于实验中满足 $1&lt;m&lt;n&lt;7$，所以使用 uint64_t 替代数组，并使用位运算进行相应计算，同时降低了空间复杂度和时间复杂度； 其中，矩阵乘法的核心代码如下： 12345// main.cpp, Line 30-33for (int i = 0; i &lt; n; i++) for (int k = 0; k &lt; m; k++) if (d[i] &gt;&gt; k &amp; 1) res.d[i] ^= rhs.d[k]; 普通的矩阵乘法的时间复杂度是 $O(n^3)$，而使用位运算后，时间复杂度降低到了 $O(n^2)$. 当已经找到了所有的陪集时，就可以停止循环，不需要再继续遍历； 12// main.cpp, Line 132if (cosetLeaders.size() == (1 &lt;&lt; (n - m))) break; 使用哈希表记录每一个码字所属的陪集，在解码的时候可以直接查找，而不需要再次遍历； 12// main.cpp, Line 123, 记录每一个码字所属的陪集visited[x] = cosetLeaders.size(); 12// main.cpp, Line 155, 直接解码printBit(Bm.d[NtoBm[cosetLeaders[visited[x]] ^ x]], m); 该哈希表还可以快速地判断当前陪集是否重复，减少了计算量； 12345// main.cpp, Line 119-122, 判断当前陪集是否重复if (visited.find(x) != visited.end()) { notFound = false; break;} 考虑到 $1&lt;m&lt;n&lt;7$，所以码字的范围最大不超过 $2^8 = 256$，所以实际上可以使用数组代替哈希表，降低部分常数. 特征值解码方式也使用了类似的方式； 12// main.cpp, Line 128, 记录每一个特征值对应的陪集(头)syndrome[getSyndrome(coset.e, H)] = cosetLeaders.size(); 12// main.cpp, Line 155, 直接获取特征值对应的陪集头并进行异或运算printBit(Bm.d[NtoBm[cosetLeaders[syndrome[s]] ^ x]], m); 使用了 lowbit 快速计算最低位的 1 的位置，加快了 bitcount 的速度. 12// main.cpp, Line 17while (n) n -= n &amp; -n, s++; 4 实验成果示例1234567891011121314151617181920212223$ ./main # 运行2 5 # 输入m n011101 #这两行是一致性校验矩阵中的 H_{m*r} 部分1. e(B^m): e(00) = 00000 e(01) = 01101 e(10) = 10011 e(11) = 111102. Cosets: 00000 | 00000 01101 10011 11110 00001 | 00001 01100 10010 11111 00010 | 00010 01111 10001 11100 00100 | 00100 01001 10111 11010 01000 | 01000 00101 11011 10110 10000 | 10000 11101 00011 01110 00110 | 00110 01011 10101 11000 01010 | 01010 00111 11001 10100Enter the number of words to decode: 3 # 在输出码字和陪集之后，在这里输入你要测试的次数Enter the word #1: 10111 (a) d(10111) = 10 (b) f(10111) = 100, ε = 00100, d(10111) = 10 #输出译码的结果······ 附录：源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cstdint&gt;#include &lt;cassert&gt;void printBit(uint64_t x, int n) { for (int i = 0; i &lt; n; i++) std::cout &lt;&lt; (x &gt;&gt; i &amp; 1);}template &lt;typename T&gt;int bitcount(T n) { int s = 0; while (n) n -= n &amp; -n, s++; return s;}class BitMatrix {public: int n, m; uint64_t d[100]; BitMatrix(int n, int m): n(n), m(m) { memset(d, 0, sizeof(uint64_t) * n); } BitMatrix operator*(const BitMatrix&amp; rhs) const { assert (m == rhs.n); BitMatrix res(n, rhs.m); for (int i = 0; i &lt; n; i++) for (int k = 0; k &lt; m; k++) if (d[i] &gt;&gt; k &amp; 1) res.d[i] ^= rhs.d[k]; return res; } void print() const { for (int i = 0; i &lt; n; i++) { printBit(d[i], m); std::cout &lt;&lt; std::endl; } }};class Coset {public: std::vector&lt;uint64_t&gt; d; // coset uint64_t e; // coset leader Coset() : e(0) {} void add(uint64_t x) { if (d.empty()) d.push_back(e = x); else { d.push_back(x); if (bitcount(x) &lt; bitcount(e)) e = x; } }};uint64_t inputBit() { std::string line; std::cin &gt;&gt; line; uint64_t x = 0; int k = 0; for (size_t i = 0; i &lt; line.size(); i++) if (line[i] == '1' || line[i] == '0') x |= (line[i] - '0') &lt;&lt; k++; return x;}BitMatrix inputH(int m, int n) { BitMatrix H(n, n - m); for (int i = 0; i &lt; m; i++) H.d[i] = inputBit(); for (int i = m; i &lt; n; i++) H.d[i] = 1 &lt;&lt; (i - m); return H;}BitMatrix HtoH2(BitMatrix &amp;H) { BitMatrix H2(H.n - H.m, H.n); for (int i = 0; i &lt; H.n - H.m; i++) H2.d[i] = 1 &lt;&lt; i; for (int i = 0; i &lt; H.n - H.m; i++) for (int j = 0; j &lt; H.m; j++) H2.d[i] |= (H.d[i] &gt;&gt; j &amp; 1) &lt;&lt; (j + H.n - H.m); return H2;}uint64_t getSyndrome(uint64_t x, BitMatrix &amp;H) { BitMatrix X(1, H.n); X.d[0] = x; return (X * H).d[0];}int main() { int m, n; std::cin &gt;&gt; m &gt;&gt; n; assert (1 &lt; m &amp;&amp; m &lt; n &amp;&amp; n &lt; 64); BitMatrix H = inputH(m, n); BitMatrix H2 = HtoH2(H), Bm(1 &lt;&lt; m, m); for (int i = 0; i &lt; (1 &lt;&lt; m); i++) for (int j = 0; j &lt; m; j++) Bm.d[i] |= (i &gt;&gt; j &amp; 1) &lt;&lt; (m - j - 1); BitMatrix N = Bm * H2; std::cout &lt;&lt; &quot;1. e(B^m):&quot; &lt;&lt; std::endl; for (int i = 0; i &lt; (1 &lt;&lt; m); i++) { std::cout &lt;&lt; &quot; e(&quot;; printBit(Bm.d[i], m); std::cout &lt;&lt; &quot;) = &quot;; printBit(N.d[i], n); std::cout &lt;&lt; std::endl; } std::unordered_map&lt;uint64_t, Coset&gt; cosets; std::unordered_map&lt;uint64_t, int&gt; visited, NtoBm, syndrome; for (int i = 0; i &lt; N.n; i++) NtoBm[N.d[i]] = i; std::vector&lt;int&gt; numbers; for (int i = 0; i &lt; (1 &lt;&lt; n); i++) numbers.push_back(i); std::sort(numbers.begin(), numbers.end(), [&amp;](int a, int b) { int ca = bitcount(a), cb = bitcount(b); return ca == cb ? a &gt; b : ca &lt; cb; }); std::vector&lt;uint64_t &gt; cosetLeaders; for (auto i : numbers) { Coset coset; bool notFound = true; for (int j = 0; j &lt; N.n; j++) { uint64_t x = N.d[j] ^ uint64_t(i); if (visited.find(x) != visited.end()) { notFound = false; break; } visited[x] = cosetLeaders.size(); coset.add(x); } if (notFound) { cosets[coset.e] = coset; syndrome[getSyndrome(coset.e, H)] = cosetLeaders.size(); cosetLeaders.push_back(coset.e); } // if cosetLeaders.size() = 2^(n-m), then stop. // Because there are only 2^(n-m) cosets. if (cosetLeaders.size() == (1 &lt;&lt; (n - m))) break; } std::cout &lt;&lt; &quot;2. Cosets:&quot; &lt;&lt; std::endl; for (auto i: cosetLeaders) { std::cout &lt;&lt; &quot; &quot;; printBit(i, n); Coset coset = cosets[i]; std::cout &lt;&lt; &quot; |&quot;; for (size_t i = 0; i &lt; coset.d.size(); i++) { std::cout &lt;&lt; &quot; &quot;; printBit(coset.d[i], n); } std::cout &lt;&lt; std::endl; } std::cerr &lt;&lt; &quot;Enter the number of words to decode: &quot;; int k; std::cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) { std::cerr &lt;&lt; &quot;Enter the word #&quot; &lt;&lt; i + 1 &lt;&lt; &quot;: &quot;; uint64_t x = inputBit(); std::cout &lt;&lt; &quot; (a) d(&quot;; printBit(x, n); std::cout &lt;&lt; &quot;) = &quot;; printBit(Bm.d[NtoBm[cosetLeaders[visited[x]] ^ x]], m); std::cout &lt;&lt; std::endl; std::cout &lt;&lt; &quot; (b) f(&quot;; printBit(x, n); uint64_t s = getSyndrome(x, H); std::cout &lt;&lt; &quot;) = &quot;; printBit(s, n - m); std::cout &lt;&lt; &quot;, ε = &quot;; printBit(cosetLeaders[syndrome[s]], n); std::cout &lt;&lt; &quot;, d(&quot;; printBit(x, n); std::cout &lt;&lt; &quot;) = &quot;; printBit(Bm.d[NtoBm[cosetLeaders[syndrome[s]] ^ x]], m); std::cout &lt;&lt; std::endl; } return 0;}","link":"/2023/12/20/%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E6%8A%80%E6%9C%AF%E7%BC%96%E7%A0%81%E8%AF%91%E7%A0%81/"},{"title":"机器学习：向量化","text":"Machine Learning: Python, NumPy and VectorizationA brief introduction to some of the scientific computing used in this course. In particular the NumPy scientific computing package and its use with python. 12import numpy as np # it is an unofficial standard to use np for numpyimport time 1.1 GoalsIn this lab, you will: Review the features of NumPy and Python that are used in Course 1 1.2 Useful References NumPy Documentation including a basic introduction: NumPy.org A challenging feature topic: NumPy Broadcasting 2 Python and NumPyPython is the programming language we will be using in this course. It has a set of numeric data types and arithmetic operations. NumPy is a library that extends the base capabilities of python to add a richer data set including more numeric types, vectors, matrices, and many matrix functions. NumPy and python work together fairly seamlessly. Python arithmetic operators work on NumPy data types and many NumPy functions will accept python data types. 3 Vectors3.1 Abstract Vectors, as you will use them in this course, are ordered arrays of numbers. In notation, vectors are denoted with lower case bold letters such as $\\mathbf{x}$. The elements of a vector are all the same type. A vector does not, for example, contain both characters and numbers. The number of elements in the array is often referred to as the dimension though mathematicians may prefer rank. The vector shown has a dimension of $n$. The elements of a vector can be referenced with an index. In math settings, indexes typically run from 1 to n. In computer science and these labs, indexing will typically run from 0 to n-1. In notation, elements of a vector, when referenced individually will indicate the index in a subscript, for example, the $0^{th}$ element, of the vector $\\mathbf{x}$ is $x_0$. Note, the x is not bold in this case. 3.2 NumPy ArraysNumPy’s basic data structure is an indexable, n-dimensional array containing elements of the same type (dtype). Right away, you may notice we have overloaded the term ‘dimension’. Above, it was the number of elements in the vector, here, dimension refers to the number of indexes of an array. A one-dimensional or 1-D array has one index. In Course 1, we will represent vectors as NumPy 1-D arrays. 1-D array, shape (n,): n elements indexed [0] through [n-1] 3.3 Vector CreationData creation routines in NumPy will generally have a first parameter which is the shape of the object. This can either be a single value for a 1-D result or a tuple (n,m,…) specifying the shape of the result. Below are examples of creating vectors using these routines. NumPy 中的数据创建例程通常会有一个第一个参数，即对象的形状。它既可以是 1-D 结果的单个值，也可以是指定结果形状的元组（n,m,…）。下面是使用这些例程创建向量的示例。 1234# NumPy routines which allocate memory and fill arrays with valuea = np.zeros(4); print(f&quot;np.zeros(4) : a = {a}, a shape = {a.shape}, a data type = {a.dtype}&quot;)a = np.zeros((4,)); print(f&quot;np.zeros(4,) : a = {a}, a shape = {a.shape}, a data type = {a.dtype}&quot;)a = np.random.random_sample(4); print(f&quot;np.random.random_sample(4): a = {a}, a shape = {a.shape}, a data type = {a.dtype}&quot;) np.zeros(4) : a = [0. 0. 0. 0.], a shape = (4,), a data type = float64 np.zeros(4,) : a = [0. 0. 0. 0.], a shape = (4,), a data type = float64 np.random.random_sample(4): a = [0.56782114 0.98895696 0.02752085 0.54867385], a shape = (4,), a data type = float64 Some data creation routines do not take a shape tuple: 123# NumPy routines which allocate memory and fill arrays with value but do not accept shape as input argumenta = np.arange(4.); print(f&quot;np.arange(4.): a = {a}, a shape = {a.shape}, a data type = {a.dtype}&quot;)a = np.random.rand(4); print(f&quot;np.random.rand(4): a = {a}, a shape = {a.shape}, a data type = {a.dtype}&quot;) np.arange(4.): a = [0. 1. 2. 3.], a shape = (4,), a data type = float64 np.random.rand(4): a = [0.19846167 0.80498665 0.46939954 0.6431181 ], a shape = (4,), a data type = float64 values can be specified manually as well. 手动指定向量值 123# NumPy routines which allocate memory and fill with user specified valuesa = np.array([5,4,3,2]); print(f&quot;np.array([5,4,3,2]): a = {a}, a shape = {a.shape}, a data type = {a.dtype}&quot;)a = np.array([5.,4,3,2]); print(f&quot;np.array([5.,4,3,2]): a = {a}, a shape = {a.shape}, a data type = {a.dtype}&quot;) np.array([5,4,3,2]): a = [5 4 3 2], a shape = (4,), a data type = int64 np.array([5.,4,3,2]): a = [5. 4. 3. 2.], a shape = (4,), a data type = float64 These have all created a one-dimensional vector a with four elements. a.shape returns the dimensions. Here we see a.shape = (4,) indicating a 1-d array with 4 elements. a(shape) = (4,) 表示有四个一维数组元素 3.4 Operations on VectorsLet’s explore some operations using vectors. 3.4.1 IndexingElements of vectors can be accessed via indexing and slicing. NumPy provides a very complete set of indexing and slicing capabilities. We will explore only the basics needed for the course here. Reference Slicing and Indexing for more details.Indexing means referring to an element of an array by its position within the array.Slicing means getting a subset of elements from an array based on their indices.NumPy starts indexing at zero so the 3rd element of an vector $\\mathbf{a}$ is a[2]. 12345678910111213141516#vector indexing operations on 1-D vectorsa = np.arange(10)print(a)#access an elementprint(f&quot;a[2].shape: {a[2].shape} a[2] = {a[2]}, Accessing an element returns a scalar&quot;)# access the last element, negative indexes count from the endprint(f&quot;a[-1] = {a[-1]}&quot;)#indexs must be within the range of the vector or they will produce and errortry: c = a[10]except Exception as e: print(&quot;The error message you'll see is:&quot;) print(e) [0 1 2 3 4 5 6 7 8 9] a[2].shape: () a[2] = 2, Accessing an element returns a scalar a[-1] = 9 The error message you'll see is: index 10 is out of bounds for axis 0 with size 10 3.4.2 SlicingSlicing creates an array of indices using a set of three values (start:stop:step). A subset of values is also valid. Its use is best explained by example: 123456789101112131415161718#vector slicing operationsa = np.arange(10)print(f&quot;a = {a}&quot;)#access 5 consecutive elements (start:stop:step)c = a[2:7:1]; print(&quot;a[2:7:1] = &quot;, c)# access 3 elements separated by two c = a[2:7:2]; print(&quot;a[2:7:2] = &quot;, c)# access all elements index 3 and abovec = a[3:]; print(&quot;a[3:] = &quot;, c)# access all elements below index 3c = a[:3]; print(&quot;a[:3] = &quot;, c)# access all elementsc = a[:]; print(&quot;a[:] = &quot;, c) a = [0 1 2 3 4 5 6 7 8 9] a[2:7:1] = [2 3 4 5 6] a[2:7:2] = [2 4 6] a[3:] = [3 4 5 6 7 8 9] a[:3] = [0 1 2] a[:] = [0 1 2 3 4 5 6 7 8 9] 3.4.3 Single vector operationsThere are a number of useful operations that involve operations on a single vector. 123456789101112131415a = np.array([1,2,3,4])print(f&quot;a : {a}&quot;)# negate elements of ab = -a print(f&quot;b = -a : {b}&quot;)# sum all elements of a, returns a scalarb = np.sum(a) print(f&quot;b = np.sum(a) : {b}&quot;)b = np.mean(a)print(f&quot;b = np.mean(a): {b}&quot;)b = a**2print(f&quot;b = a**2 : {b}&quot;) a : [1 2 3 4] b = -a : [-1 -2 -3 -4] b = np.sum(a) : 10 b = np.mean(a): 2.5 b = a**2 : [ 1 4 9 16] 3.4.4 Vector Vector element-wise operationsMost of the NumPy arithmetic, logical and comparison operations apply to vectors as well. These operators work on an element-by-element basis. For example$$ c_i = a_i + b_i $$ 123a = np.array([ 1, 2, 3, 4])b = np.array([-1,-2, 3, 4])print(f&quot;Binary operators work element wise: {a + b}&quot;) Binary operators work element wise: [0 0 6 8] Of course, for this to work correctly, the vectors must be of the same size: 1234567#try a mismatched vector operationc = np.array([1, 2])try: d = a + cexcept Exception as e: print(&quot;The error message you'll see is:&quot;) print(e) The error message you'll see is: operands could not be broadcast together with shapes (4,) (2,) 3.4.5 Scalar Vector operationsVectors can be ‘scaled’ by scalar values. A scalar value is just a number. The scalar multiplies all the elements of the vector. 12345a = np.array([1, 2, 3, 4])# multiply a by a scalarb = 5 * a print(f&quot;b = 5 * a : {b}&quot;) b = 5 * a : [ 5 10 15 20] 3.4.6 Vector Vector dot productThe dot product is a mainstay of Linear Algebra and NumPy. This is an operation used extensively in this course and should be well understood. The dot product is shown below. The dot product multiplies the values in two vectors element-wise and then sums the result.Vector dot product requires the dimensions of the two vectors to be the same. Let’s implement our own version of the dot product below: Using a for loop, implement a function which returns the dot product of two vectors. The function to return given inputs $a$ and $b$:$$ x = \\sum_{i=0}^{n-1} a_i b_i $$Assume both a and b are the same shape. 123456789101112131415def my_dot(a, b): &quot;&quot;&quot; Compute the dot product of two vectors Args: a (ndarray (n,)): input vector b (ndarray (n,)): input vector with same dimension as a Returns: x (scalar): &quot;&quot;&quot; x=0 for i in range(a.shape[0]): x = x + a[i] * b[i] return x 1234# test 1-Da = np.array([1, 2, 3, 4])b = np.array([-1, 4, 3, 2])print(f&quot;my_dot(a, b) = {my_dot(a, b)}&quot;) my_dot(a, b) = 24 Note, the dot product is expected to return a scalar value. Let’s try the same operations using np.dot. 12345678# test 1-Da = np.array([1, 2, 3, 4])b = np.array([-1, 4, 3, 2])c = np.dot(a, b)print(f&quot;NumPy 1-D np.dot(a, b) = {c}, np.dot(a, b).shape = {c.shape} &quot;) c = np.dot(b, a)print(f&quot;NumPy 1-D np.dot(b, a) = {c}, np.dot(a, b).shape = {c.shape} &quot;) NumPy 1-D np.dot(a, b) = 24, np.dot(a, b).shape = () NumPy 1-D np.dot(b, a) = 24, np.dot(a, b).shape = () Above, you will note that the results for 1-D matched our implementation. 3.4.7 The Need for Speed: vector vs for loopWe utilized the NumPy library because it improves speed memory efficiency. Let’s demonstrate: 12345678910111213141516171819np.random.seed(1)a = np.random.rand(10000000) # very large arraysb = np.random.rand(10000000)tic = time.time() # capture start timec = np.dot(a, b)toc = time.time() # capture end timeprint(f&quot;np.dot(a, b) = {c:.4f}&quot;)print(f&quot;Vectorized version duration: {1000*(toc-tic):.4f} ms &quot;)tic = time.time() # capture start timec = my_dot(a,b)toc = time.time() # capture end timeprint(f&quot;my_dot(a, b) = {c:.4f}&quot;)print(f&quot;loop version duration: {1000*(toc-tic):.4f} ms &quot;)del(a);del(b) #remove these big arrays from memory np.dot(a, b) = 2501072.5817 Vectorized version duration: 179.0733 ms my_dot(a, b) = 2501072.5817 loop version duration: 9144.5312 ms So, vectorization provides a large speed up in this example. This is because NumPy makes better use of available data parallelism in the underlying hardware. GPU’s and modern CPU’s implement Single Instruction, Multiple Data (SIMD) pipelines allowing multiple operations to be issued in parallel. This is critical in Machine Learning where the data sets are often very large. 3.4.8 Vector Vector operations in Course 1Vector Vector operations will appear frequently in course 1. Here is why: Going forward, our examples will be stored in an array, X_train of dimension (m,n). This will be explained more in context, but here it is important to note it is a 2 Dimensional array or matrix (see next section on matrices). w will be a 1-dimensional vector of shape (n,). we will perform operations by looping through the examples, extracting each example to work on individually by indexing X. For example:X[i] X[i] returns a value of shape (n,), a 1-dimensional vector. Consequently, operations involving X[i] are often vector-vector. That is a somewhat lengthy explanation, but aligning and understanding the shapes of your operands is important when performing vector operations. 12345678# show common Course 1 exampleX = np.array([[1],[2],[3],[4]])w = np.array([2])c = np.dot(X[1], w)print(f&quot;X[1] has shape {X[1].shape}&quot;)print(f&quot;w has shape {w.shape}&quot;)print(f&quot;c has shape {c.shape}&quot;) X[1] has shape (1,) w has shape (1,) c has shape () 4 Matrices4.1 AbstractMatrices, are two dimensional arrays. The elements of a matrix are all of the same type. In notation, matrices are denoted with capitol, bold letter such as $\\mathbf{X}$. In this and other labs, m is often the number of rows and n the number of columns. The elements of a matrix can be referenced with a two dimensional index. In math settings, numbers in the index typically run from 1 to n. In computer science and these labs, indexing will run from 0 to n-1. 4.2 NumPy ArraysNumPy’s basic data structure is an indexable, n-dimensional array containing elements of the same type (dtype). These were described earlier. Matrices have a two-dimensional (2-D) index [m,n]. In Course 1, 2-D matrices are used to hold training data. Training data is $m$ examples by $n$ features creating an (m,n) array. Course 1 does not do operations directly on matrices but typically extracts an example as a vector and operates on that. Below you will review: data creation slicing and indexing 4.3 Matrix CreationThe same functions that created 1-D vectors will create 2-D or n-D arrays. Here are some examples Below, the shape tuple is provided to achieve a 2-D result. Notice how NumPy uses brackets to denote each dimension. Notice further than NumPy, when printing, will print one row per line. 12345678a = np.zeros((1, 5)) print(f&quot;a shape = {a.shape}, a = {a}&quot;) a = np.zeros((2, 1)) print(f&quot;a shape = {a.shape}, a = {a}&quot;) a = np.random.random_sample((1, 1)) print(f&quot;a shape = {a.shape}, a = {a}&quot;) a shape = (1, 5), a = [[0. 0. 0. 0. 0.]] a shape = (2, 1), a = [[0.] [0.]] a shape = (1, 1), a = [[0.44236513]] One can also manually specify data. Dimensions are specified with additional brackets matching the format in the printing above. 123456# NumPy routines which allocate memory and fill with user specified valuesa = np.array([[5], [4], [3]]); print(f&quot; a shape = {a.shape}, np.array: a = {a}&quot;)a = np.array([[5], # One can also [4], # separate values [3]]); #into separate rowsprint(f&quot; a shape = {a.shape}, np.array: a = {a}&quot;) a shape = (3, 1), np.array: a = [[5] [4] [3]] a shape = (3, 1), np.array: a = [[5] [4] [3]] 4.4 Operations on MatricesLet’s explore some operations using matrices. 4.4.1 IndexingMatrices include a second index. The two indexes describe [row, column]. Access can either return an element or a row/column. See below: 123456789#vector indexing operations on matricesa = np.arange(6).reshape(-1, 2) #reshape is a convenient way to create matricesprint(f&quot;a.shape: {a.shape}, \\na= {a}&quot;)#access an elementprint(f&quot;\\na[2,0].shape: {a[2, 0].shape}, a[2,0] = {a[2, 0]}, type(a[2,0]) = {type(a[2, 0])} Accessing an element returns a scalar\\n&quot;)#access a rowprint(f&quot;a[2].shape: {a[2].shape}, a[2] = {a[2]}, type(a[2]) = {type(a[2])}&quot;) a.shape: (3, 2), a= [[0 1] [2 3] [4 5]] a[2,0].shape: (), a[2,0] = 4, type(a[2,0]) = &lt;class 'numpy.int64'&gt; Accessing an element returns a scalar a[2].shape: (2,), a[2] = [4 5], type(a[2]) = &lt;class 'numpy.ndarray'&gt; It is worth drawing attention to the last example. Accessing a matrix by just specifying the row will return a 1-D vector. ReshapeThe previous example used reshape to shape the array.a = np.arange(6).reshape(-1, 2) This line of code first created a 1-D Vector of six elements. It then reshaped that vector into a 2-D array using the reshape command. This could have been written:a = np.arange(6).reshape(3, 2) To arrive at the same 3 row, 2 column array.The -1 argument tells the routine to compute the number of rows given the size of the array and the number of columns. 4.4.2 SlicingSlicing creates an array of indices using a set of three values (start:stop:step). A subset of values is also valid. Its use is best explained by example: 123456789101112131415161718#vector 2-D slicing operationsa = np.arange(20).reshape(-1, 10)print(f&quot;a = \\n{a}&quot;)#access 5 consecutive elements (start:stop:step)print(&quot;a[0, 2:7:1] = &quot;, a[0, 2:7:1], &quot;, a[0, 2:7:1].shape =&quot;, a[0, 2:7:1].shape, &quot;a 1-D array&quot;)#access 5 consecutive elements (start:stop:step) in two rowsprint(&quot;a[:, 2:7:1] = \\n&quot;, a[:, 2:7:1], &quot;, a[:, 2:7:1].shape =&quot;, a[:, 2:7:1].shape, &quot;a 2-D array&quot;)# access all elementsprint(&quot;a[:,:] = \\n&quot;, a[:,:], &quot;, a[:,:].shape =&quot;, a[:,:].shape)# access all elements in one row (very common usage)print(&quot;a[1,:] = &quot;, a[1,:], &quot;, a[1,:].shape =&quot;, a[1,:].shape, &quot;a 1-D array&quot;)# same asprint(&quot;a[1] = &quot;, a[1], &quot;, a[1].shape =&quot;, a[1].shape, &quot;a 1-D array&quot;) a = [[ 0 1 2 3 4 5 6 7 8 9] [10 11 12 13 14 15 16 17 18 19]] a[0, 2:7:1] = [2 3 4 5 6] , a[0, 2:7:1].shape = (5,) a 1-D array a[:, 2:7:1] = [[ 2 3 4 5 6] [12 13 14 15 16]] , a[:, 2:7:1].shape = (2, 5) a 2-D array a[:,:] = [[ 0 1 2 3 4 5 6 7 8 9] [10 11 12 13 14 15 16 17 18 19]] , a[:,:].shape = (2, 10) a[1,:] = [10 11 12 13 14 15 16 17 18 19] , a[1,:].shape = (10,) a 1-D array a[1] = [10 11 12 13 14 15 16 17 18 19] , a[1].shape = (10,) a 1-D array Congratulations!In this lab you mastered the features of Python and NumPy that are needed for Course 1.","link":"/2023/10/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A01/"},{"title":"Linked list - Implementation in C","text":"链表是一种常见的数据结构，它的基本单位是node，由data和link两部分组成。 创建一个链表需要以下几个步骤：1.创建节点的结构体一个简单的结构体，由数据和结构体指针构成，代码如下： 1234struct Node{ int data; struct Node* link;}; 2.创建变量保存头节点的地址12struct Node* head;head = NULL; 3.在堆区为节点开辟一个动态空间1struct Node* temp = (struct Node*)malloc(sizeof(struct Node)); 4.为节点赋值12temp-&gt;data = 2;temp-&gt;link = NULL; 5.更改头节点的地址1head = temp; 下面尝试遍历一个链表，并逐个数输出12345struct Node* temp1 = head;while(temp -&gt; link != NULL){ printf(&quot;%d &quot;,temp1-&gt;data); temp1 = temp1-&gt;link;}","link":"/2023/01/02/202312-Linked-list---Implementation-in-C/"}],"tags":[{"name":"年度总结","slug":"年度总结","link":"/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"},{"name":"2023","slug":"2023","link":"/tags/2023/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Internet","slug":"Internet","link":"/tags/Internet/"},{"name":"diffusers","slug":"diffusers","link":"/tags/diffusers/"},{"name":"tutorials","slug":"tutorials","link":"/tags/tutorials/"},{"name":"2024","slug":"2024","link":"/tags/2024/"},{"name":"科幻小说","slug":"科幻小说","link":"/tags/%E7%A7%91%E5%B9%BB%E5%B0%8F%E8%AF%B4/"},{"name":"AI","slug":"AI","link":"/tags/AI/"},{"name":"大作业","slug":"大作业","link":"/tags/%E5%A4%A7%E4%BD%9C%E4%B8%9A/"},{"name":"离散数学","slug":"离散数学","link":"/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"},{"name":"编码","slug":"编码","link":"/tags/%E7%BC%96%E7%A0%81/"}],"categories":[{"name":"年度总结","slug":"年度总结","link":"/categories/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"},{"name":"计算机网络","slug":"计算机网络","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"diffusers","slug":"diffusers","link":"/categories/diffusers/"},{"name":"大作业","slug":"大作业","link":"/categories/%E5%A4%A7%E4%BD%9C%E4%B8%9A/"},{"name":"计算机网络大作业","slug":"计算机网络大作业","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%A7%E4%BD%9C%E4%B8%9A/"}],"pages":[]}